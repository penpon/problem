<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScriptå¯è¦–åŒ–ãƒ„ãƒ¼ãƒ«</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .main-content {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            align-items: flex-start;
        }

        .left-panel {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 20px;
        }

        .right-panel {
            flex: 0 0 350px;
            height: calc(100vh - 40px);
            position: sticky;
            top: 20px;
            min-width: 250px;
            max-width: 600px;
            align-self: flex-start;
        }

        .resize-handle {
            width: 8px;
            height: calc(100vh - 40px);
            background: #ddd;
            cursor: col-resize;
            position: sticky;
            top: 20px;
            border-left: 1px solid #ccc;
            border-right: 1px solid #ccc;
            transition: background 0.2s ease;
            align-self: flex-start;
        }

        .resize-handle:hover {
            background: #bbb;
        }

        .resize-handle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 30px;
            background: #888;
            border-radius: 2px;
        }

        .resize-handle:hover::before {
            color: #333;
        }

        .resize-handle:active {
            background: linear-gradient(to right, #ccc, #aaa, #ccc);
            border-color: #777;
        }

        .input-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-section {
            background: #f1f3f4;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #dadce0;
        }

        .code-section {
            background: #f8f8ff;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ddd6fe;
            max-height: 600px;
            overflow-y: auto;
            grid-column: 1 / -1;
        }

        .code-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .code-section-header h2 {
            margin: 0;
        }

        .output-section {
            background: #f0fdf4;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #bbf7d0;
            height: calc(100vh - 80px);
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .output-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #bbf7d0;
            padding-bottom: 10px;
        }

        .output-panel-header h2 {
            margin: 0;
            color: #059669;
        }

        .panel-toggle-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }

        .panel-toggle-btn:hover {
            background: #059669;
        }

        .right-panel.collapsed {
            flex: 0 0 40px;
        }

        .right-panel.collapsed .output-section {
            display: none;
        }

        .right-panel.collapsed + .resize-handle {
            display: none;
        }


        .panel-expand-btn {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%) rotate(-90deg);
            background: #10b981;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            writing-mode: vertical-lr;
        }

        .code-input {
            width: 100%;
            height: 400px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            background: #fff;
            resize: vertical;
        }

        .code-container {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            overflow-x: auto;
            position: relative;
        }

        .floating-auto-scroll-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            font-size: 14px;
            background: rgba(33, 150, 243, 0.9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 9999;
            transition: all 0.3s ease;
            opacity: 0.8;
            backdrop-filter: blur(6px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .floating-auto-scroll-btn:hover {
            opacity: 1;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }

        .floating-auto-scroll-btn.active {
            background: rgba(40, 167, 69, 0.8);
        }

        .floating-auto-scroll-btn.active:hover {
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        .code-line {
            padding: 2px 0;
            position: relative;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            min-height: 20px;
        }

        .code-line.highlight {
            background: #264f78;
            border-left: 4px solid #ffc107;
            padding-left: 8px;
            margin-left: -8px;
            transform: translateX(4px);
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.3);
        }

        .code-line.executing {
            background: #0e4429;
            border-left: 4px solid #28a745;
            padding-left: 8px;
            margin-left: -8px;
            animation: executeGlow 1s infinite;
        }

        @keyframes executeGlow {
            0% { box-shadow: 0 0 5px rgba(40, 167, 69, 0.5); }
            50% { box-shadow: 0 0 15px rgba(40, 167, 69, 0.8); }
            100% { box-shadow: 0 0 5px rgba(40, 167, 69, 0.5); }
        }

        .line-number {
            color: #858585;
            display: inline-block;
            width: 30px;
            text-align: right;
            margin-right: 15px;
            user-select: none;
        }

        .comment {
            color: #6a9955;
        }

        .keyword {
            color: #569cd6;
        }

        .string {
            color: #ce9178;
        }

        .function-name {
            color: #dcdcaa;
        }

        .variable {
            color: #9cdcfe;
        }

        .code-content {
            flex: 1;
            display: flex;
            align-items: center;
        }

        .variable-overlay {
            margin-left: 20px;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            background: rgba(40, 167, 69, 0.15);
            border: 1px solid rgba(40, 167, 69, 0.3);
            color: #28a745;
            opacity: 0;
            transition: all 0.5s ease;
            white-space: nowrap;
            max-width: 500px;
            min-width: 180px;
            overflow: visible;
            box-shadow: 0 2px 6px rgba(40, 167, 69, 0.2);
            position: relative;
        }
        
        .variable-overlay::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-right: 8px solid rgba(40, 167, 69, 0.3);
        }

        .variable-overlay.visible {
            opacity: 1;
        }

        .variable-overlay.changed {
            background: rgba(255, 193, 7, 0.3);
            border: 1px solid rgba(255, 193, 7, 0.6);
            color: #ffc107;
            animation: variableOverlayChange 1.5s ease;
        }
        
        .variable-overlay.function-type {
            background: rgba(156, 39, 176, 0.15);
            border: 1px solid rgba(156, 39, 176, 0.3);
            color: #9c27b0;
        }
        
        .variable-overlay.function-type::before {
            border-right-color: rgba(156, 39, 176, 0.3);
        }
        
        .variable-overlay.object-type {
            background: rgba(33, 150, 243, 0.15);
            border: 1px solid rgba(33, 150, 243, 0.3);
            color: #2196f3;
        }
        
        .variable-overlay.object-type::before {
            border-right-color: rgba(33, 150, 243, 0.3);
        }
        
        .variable-overlay.error-type {
            background: rgba(244, 67, 54, 0.15);
            border: 1px solid rgba(244, 67, 54, 0.3);
            color: #f44336;
        }
        
        .variable-overlay.error-type::before {
            border-right-color: rgba(244, 67, 54, 0.3);
        }

        @keyframes variableOverlayChange {
            0% {
                background: rgba(40, 167, 69, 0.5);
                transform: scale(1.05);
            }
            50% {
                background: rgba(255, 193, 7, 0.5);
                transform: scale(1.02);
            }
            100% {
                background: rgba(255, 193, 7, 0.3);
                transform: scale(1);
            }
        }

        .controls {
            text-align: center;
            margin: 30px 0;
        }

        .control-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .control-group label {
            font-weight: bold;
            color: #333;
            min-width: 120px;
            text-align: right;
        }

        select, button {
            padding: 10px 20px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button {
            background: linear-gradient(145deg, #2196f3, #1976d2);
            color: white;
            border: none;
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .reset-btn {
            background: linear-gradient(145deg, #ff9800, #f57c00);
        }

        .reset-btn:hover {
            box-shadow: 0 5px 15px rgba(255, 152, 0, 0.4);
        }

        .step-btn {
            background: linear-gradient(145deg, #673ab7, #5e35b1);
            color: white;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .step-btn:hover {
            box-shadow: 0 5px 15px rgba(103, 58, 183, 0.4);
            transform: translateY(-2px);
        }

        .step-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .step-info {
            background: #e8eaf6;
            border: 2px solid #673ab7;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .step-info h4 {
            margin: 0 0 10px 0;
            color: #673ab7;
            font-size: 1.1em;
        }

        .step-counter {
            font-size: 1.2em;
            font-weight: bold;
            color: #5e35b1;
        }

        .execution-mode {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .radio-label:hover {
            color: #2196f3;
        }

        .radio-label input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .speed-control {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .speed-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .speed-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: linear-gradient(145deg, #e3f2fd, #bbdefb);
            color: #1976d2;
            border: 2px solid #2196f3;
        }

        .speed-btn.active {
            background: linear-gradient(145deg, #2196f3, #1976d2);
            color: white;
        }

        .output-console {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .console-line {
            margin: 2px 0;
            word-break: break-all;
        }

        .error {
            color: #ff4444;
        }

        .warning {
            color: #ffaa00;
        }

        .sample-codes {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .sample-code-btn {
            background: linear-gradient(145deg, #4caf50, #45a049);
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .sample-code-btn:hover {
            background: linear-gradient(145deg, #45a049, #4caf50);
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto;
                gap: 15px;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .right-panel,
            .resize-handle {
                position: relative;
                top: auto;
                height: auto;
                min-height: 300px;
            }
            
            .output-section {
                height: auto;
                max-height: 400px;
            }
            
            .variable-overlay {
                margin-left: 10px;
                max-width: 250px;
                font-size: 11px;
            }
            
            .code-section {
                max-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” JavaScriptå¯è¦–åŒ–ãƒ„ãƒ¼ãƒ«</h1>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="input-section">
                    <h2>ğŸ“ ã‚³ãƒ¼ãƒ‰å…¥åŠ›</h2>
                    <textarea 
                        id="codeInput" 
                        class="code-input" 
                        placeholder="ã“ã“ã«JavaScriptã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."
                        oninput="displayCode(this.value)"
                    ></textarea>
                    
                    <div class="sample-codes">
                        <h4>ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ï¼š</h4>
                        <button class="sample-code-btn" onclick="loadSampleCode('variables')">å¤‰æ•°æ“ä½œ</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('array')">é…åˆ—æ“ä½œ</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('loop')">ãƒ«ãƒ¼ãƒ—å‡¦ç†</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('conditional')">æ¡ä»¶åˆ†å²</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('functions')">é–¢æ•°å®šç¾©</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('objects')">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('switchCase')">Switchæ–‡</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('arrayMethods')">é…åˆ—æ“ä½œ2</button>
                    </div>
                </div>

                <div class="control-section">
                    <h2>âš™ï¸ å®Ÿè¡Œåˆ¶å¾¡</h2>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰:</label>
                            <div class="execution-mode">
                                <label class="radio-label">
                                    <input type="radio" name="executionMode" value="auto" checked onchange="onExecutionModeChange()">
                                    å…¨è‡ªå‹•å®Ÿè¡Œ
                                </label>
                                <label class="radio-label">
                                    <input type="radio" name="executionMode" value="step" onchange="onExecutionModeChange()">
                                    ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ
                                </label>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <button id="executeBtn" onclick="startExecution()">ğŸš€ å®Ÿè¡Œé–‹å§‹</button>
                            <button id="nextStepBtn" class="step-btn" onclick="nextStep()" style="display: none;">â–¶ï¸ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—</button>
                            <button class="reset-btn" onclick="resetExecution()">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
                        </div>
                        
                        <div class="step-info" id="stepInfo" style="display: none;">
                            <h4>ğŸ”„ ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰</h4>
                            <div class="step-counter">ã‚¹ãƒ†ãƒƒãƒ— 0/0</div>
                            <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                                ã€Œæ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é€²ã‚“ã§ãã ã•ã„
                            </div>
                        </div>
                    </div>

                    <div class="speed-control">
                        <h3>âš¡ å®Ÿè¡Œé€Ÿåº¦</h3>
                        <div class="speed-buttons">
                            <button class="speed-btn" onclick="setSpeed(0.25)">0.25x (ã‚†ã£ãã‚Š)</button>
                            <button class="speed-btn active" onclick="setSpeed(0.5)">0.5x (æ¨™æº–)</button>
                            <button class="speed-btn" onclick="setSpeed(1)">1x (é«˜é€Ÿ)</button>
                        </div>
                    </div>

                </div>

                <div class="code-section">
                    <div class="code-section-header">
                        <h2>ğŸ’» å®Ÿè¡Œã‚³ãƒ¼ãƒ‰</h2>
                    </div>
                    <div class="code-container" id="codeContainer">
                        <!-- ã‚³ãƒ¼ãƒ‰ã¯ JavaScript ã§ç”Ÿæˆ -->
                    </div>
                </div>
            </div>

            <div class="resize-handle" id="resizeHandle"></div>

            <div class="right-panel" id="rightPanel">
                <div class="output-section">
                    <div class="output-panel-header">
                        <h2>ğŸ“„ å®Ÿè¡Œçµæœ</h2>
                        <button class="panel-toggle-btn" onclick="toggleOutputPanel()">éè¡¨ç¤º</button>
                    </div>
                    <div class="output-console" id="outputConsole">
                        <div class="console-line">ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...</div>
                    </div>
                </div>
                <button class="panel-expand-btn" onclick="toggleOutputPanel()" style="display: none;">å®Ÿè¡Œçµæœ</button>
            </div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let animationSpeed = 0.5; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé€Ÿåº¦
        let isProcessing = false;
        let currentStep = 0; // ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—ç•ªå·
        let totalSteps = 0; // ç·ã‚¹ãƒ†ãƒƒãƒ—æ•°
        let nextStepResolve = null; // æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—å¾…ã¡ã®Promise resolve
        let stepWaiting = false; // ã‚¹ãƒ†ãƒƒãƒ—å¾…æ©Ÿä¸­ãƒ•ãƒ©ã‚°
        let executionMode = 'auto'; // å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰: 'step' or 'auto'
        let codeLines = []; // è§£æã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰è¡Œ
        let variables = {}; // å®Ÿè¡Œä¸­ã®å¤‰æ•°çŠ¶æ…‹
        let consoleOutput = []; // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›
        let executionSteps = []; // å®Ÿè¡Œã‚¹ãƒ†ãƒƒãƒ—
        let currentScope = {}; // ç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—
        let scopeStack = []; // ã‚¹ã‚³ãƒ¼ãƒ—ã‚¹ã‚¿ãƒƒã‚¯
        let loopCounters = {}; // ãƒ«ãƒ¼ãƒ—ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
        let userScrolling = false; // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ‰‹å‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸­ã‹ã©ã†ã‹
        let scrollTimeout = null; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
        let autoScrollEnabled = true; // ã‚ªãƒ¼ãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ©Ÿèƒ½ã®æœ‰åŠ¹/ç„¡åŠ¹
        let executionAborted = false; // å®Ÿè¡Œä¸­æ–­ãƒ•ãƒ©ã‚°
        let currentTimeouts = new Set(); // ç¾åœ¨ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆIDã‚’è¿½è·¡

        // ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
        const sampleCodes = {
            variables: `let name = "å¤ªéƒ";
let age = 25;
let isStudent = true;

console.log("åå‰: " + name);
console.log("å¹´é½¢: " + age);

if (isStudent) {
    console.log("å­¦ç”Ÿã§ã™");
} else {
    console.log("ç¤¾ä¼šäººã§ã™");
}

age = age + 1;
console.log("æ¥å¹´ã®å¹´é½¢: " + age);`,

            array: `let numbers = [1, 2, 3, 4, 5];
let sum = 0;

console.log("é…åˆ—: " + numbers);

for (let i = 0; i < numbers.length; i++) {
    sum = sum + numbers[i];
    console.log("i=" + i + ", sum=" + sum);
}

console.log("åˆè¨ˆ: " + sum);`,

            loop: `let count = 0;
let max = 5;

console.log("ã‚«ã‚¦ãƒ³ãƒˆã‚¢ãƒƒãƒ—é–‹å§‹");

while (count < max) {
    count = count + 1;
    console.log("count: " + count);
}

console.log("ã‚«ã‚¦ãƒ³ãƒˆå®Œäº†");`,

            conditional: `let score = 85;
let grade;

console.log("ç‚¹æ•°: " + score);

if (score >= 90) {
    grade = "A";
} else if (score >= 80) {
    grade = "B";
} else if (score >= 70) {
    grade = "C";
} else {
    grade = "D";
}

console.log("è©•ä¾¡: " + grade);`,

            functions: `function add(a, b) {
    let result = a + b;
    console.log(a + " + " + b + " = " + result);
    return result;
}

function greet(name) {
    console.log("ã“ã‚“ã«ã¡ã¯ã€" + name + "ã•ã‚“ï¼");
}

let x = 10;
let y = 20;
let sum = add(x, y);
greet("ç”°ä¸­");
console.log("æœ€çµ‚çµæœ: " + sum);`,

            objects: `let person = {
    name: "å±±ç”°å¤ªéƒ",
    age: 30,
    city: "æ±äº¬"
};

console.log("åå‰: " + person.name);
console.log("å¹´é½¢: " + person.age);
console.log("ä½æ‰€: " + person.city);

person.age = person.age + 1;
console.log("æ¥å¹´ã®å¹´é½¢: " + person.age);`,

            switchCase: `let day = 3;
let dayName;

switch (day) {
    case 1:
        dayName = "æœˆæ›œæ—¥";
        break;
    case 2:
        dayName = "ç«æ›œæ—¥";
        break;
    case 3:
        dayName = "æ°´æ›œæ—¥";
        break;
    default:
        dayName = "ä¸æ˜";
        break;
}

console.log("ä»Šæ—¥ã¯" + dayName + "ã§ã™");`,

            arrayMethods: `let numbers = [1, 2, 3, 4, 5];
let doubled = [];

console.log("å…ƒã®é…åˆ—: " + numbers);

for (let i = 0; i < numbers.length; i++) {
    doubled[i] = numbers[i] * 2;
    console.log(numbers[i] + " Ã— 2 = " + doubled[i]);
}

console.log("2å€ã—ãŸé…åˆ—: " + doubled);`
        };

        // åˆæœŸåŒ–
        function init() {
            displayCode('');
            updateExecutionModeUI();
            clearConsole();
            loadSampleCode('variables'); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚µãƒ³ãƒ—ãƒ«
            detectUserScrolling(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ¤œå‡ºã‚’æœ‰åŠ¹åŒ–
            initializeResize(); // ãƒ‘ãƒãƒ«ãƒªã‚µã‚¤ã‚ºæ©Ÿèƒ½ã‚’åˆæœŸåŒ–
        }

        // ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã®èª­ã¿è¾¼ã¿
        function loadSampleCode(type) {
            if (sampleCodes[type]) {
                document.getElementById('codeInput').value = sampleCodes[type];
                displayCode(sampleCodes[type]);
                resetExecution();
            }
        }

        // ã‚³ãƒ¼ãƒ‰è¡¨ç¤ºé–¢æ•°
        function displayCode(code) {
            const container = document.getElementById('codeContainer');
            
            // ã‚ªãƒ¼ãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’ä¿å­˜
            const existingBtn = document.getElementById('autoScrollBtn');
            let buttonActive = true;
            if (existingBtn) {
                buttonActive = existingBtn.classList.contains('active');
                existingBtn.remove(); // æ—¢å­˜ã®ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
            }
            
            if (!code.trim()) {
                container.innerHTML = '<div class="console-line">ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„...</div>';
                // ãƒœã‚¿ãƒ³ã‚’bodyè¦ç´ ã«è¿½åŠ ï¼ˆãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå›ºå®šï¼‰
                const buttonHtml = `<button id="autoScrollBtn" class="floating-auto-scroll-btn ${buttonActive ? 'active' : ''}" onclick="toggleAutoScroll()">${buttonActive ? 'ğŸ“ ON' : 'ğŸš« OFF'}</button>`;
                document.body.insertAdjacentHTML('beforeend', buttonHtml);
                return;
            }
            
            codeLines = code.split('\n');
            
            const codeHtml = codeLines.map((line, index) => {
                const lineNumber = index + 1;
                
                // å…ƒã®ã‚³ãƒ¼ãƒ‰ã‚’ãã®ã¾ã¾è¡¨ç¤ºï¼ˆHTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã®ã¿ï¼‰
                let displayLine = line
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#x27;');
                
                return `<div class="code-line" id="code-line-${lineNumber}">
                    <div class="code-content">
                        <span class="line-number">${lineNumber}</span>${displayLine}
                    </div>
                    <div class="variable-overlay" id="overlay-line-${lineNumber}"></div>
                </div>`;
            }).join('');
            
            // ã‚³ãƒ¼ãƒ‰ã®ã¿ã‚’è¨­å®š
            container.innerHTML = codeHtml;
            
            // ãƒœã‚¿ãƒ³ã‚’bodyè¦ç´ ã«è¿½åŠ ï¼ˆãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå›ºå®šï¼‰
            const buttonHtml = `<button id="autoScrollBtn" class="floating-auto-scroll-btn ${buttonActive ? 'active' : ''}" onclick="toggleAutoScroll()">${buttonActive ? 'ğŸ“ ON' : 'ğŸš« OFF'}</button>`;
            document.body.insertAdjacentHTML('beforeend', buttonHtml);
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ“ä½œã‚’æ¤œå‡º
        function detectUserScrolling() {
            const codeSection = document.querySelector('.code-section');
            if (codeSection) {
                codeSection.addEventListener('scroll', () => {
                    userScrolling = true;
                    if (scrollTimeout) {
                        clearTimeout(scrollTimeout);
                        currentTimeouts.delete(scrollTimeout);
                    }
                    // 3ç§’å¾Œã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                    scrollTimeout = setTimeout(() => {
                        currentTimeouts.delete(scrollTimeout);
                        userScrolling = false;
                    }, 3000);
                    currentTimeouts.add(scrollTimeout);
                });
            }
        }

        // ã‚ªãƒ¼ãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
        function toggleAutoScroll() {
            autoScrollEnabled = !autoScrollEnabled;
            const btn = document.getElementById('autoScrollBtn');
            if (autoScrollEnabled) {
                btn.textContent = 'ğŸ“ ON';
                btn.classList.add('active');
            } else {
                btn.textContent = 'ğŸš« OFF';
                btn.classList.remove('active');
            }
        }

        // ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ©ã‚¤ãƒˆé–¢æ•°
        function highlightCodeLine(lineNumber, duration = 1000) {
            // ãƒªã‚»ãƒƒãƒˆ
            document.querySelectorAll('.code-line').forEach(line => {
                line.classList.remove('highlight', 'executing');
            });
            
            // æŒ‡å®šè¡Œã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            const codeLine = document.getElementById(`code-line-${lineNumber}`);
            if (codeLine) {
                codeLine.classList.add('executing');
                
                // ã‚ªãƒ¼ãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒæœ‰åŠ¹ã‹ã¤ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸­ã§ãªã„å ´åˆã®ã¿è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                if (autoScrollEnabled && !userScrolling) {
                    setTimeout(() => {
                        codeLine.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center' 
                        });
                    }, 100);
                }
                
                // æŒ‡å®šæ™‚é–“å¾Œã«ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’å®Œäº†ã«å¤‰æ›´
                const timeoutId = setTimeout(() => {
                    currentTimeouts.delete(timeoutId);
                    codeLine.classList.remove('executing');
                    codeLine.classList.add('highlight');
                }, duration / animationSpeed);
                
                // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆIDã‚’è¿½è·¡
                currentTimeouts.add(timeoutId);
            }
        }

        // ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ãƒªã‚»ãƒƒãƒˆ
        function resetCodeHighlight() {
            document.querySelectorAll('.code-line').forEach(line => {
                line.classList.remove('highlight', 'executing');
            });
        }

        // é«˜åº¦ãªå¤‰æ•°è¿½è·¡æ©Ÿèƒ½
        class VariableTracker {
            constructor() {
                this.variables = {};
                this.variableHistory = new Map(); // å¤‰æ•°ã®å¤‰æ›´å±¥æ­´
                this.lineToVariables = new Map(); // è¡Œç•ªå·ã‹ã‚‰å¤‰æ•°ã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°
            }

            // å¤‰æ•°ã‚’è¨­å®š
            setVariable(name, value, lineNumber, changeType = 'assignment') {
                const previousValue = this.variables[name];
                this.variables[name] = value;
                
                // å±¥æ­´ã‚’è¨˜éŒ²
                if (!this.variableHistory.has(name)) {
                    this.variableHistory.set(name, []);
                }
                this.variableHistory.get(name).push({
                    value: value,
                    lineNumber: lineNumber,
                    changeType: changeType,
                    timestamp: Date.now()
                });
                
                // è¡Œã¨å¤‰æ•°ã®é–¢é€£ä»˜ã‘
                if (!this.lineToVariables.has(lineNumber)) {
                    this.lineToVariables.set(lineNumber, []);
                }
                this.lineToVariables.get(lineNumber).push({
                    name: name,
                    value: value,
                    previousValue: previousValue,
                    changeType: changeType
                });
                
                return { previousValue, newValue: value };
            }

            // å¤‰æ•°ã‚’å–å¾—
            getVariable(name) {
                return this.variables[name];
            }

            // ã™ã¹ã¦ã®å¤‰æ•°ã‚’å–å¾—
            getAllVariables() {
                return { ...this.variables };
            }

            // æŒ‡å®šè¡Œã®å¤‰æ•°å¤‰æ›´ã‚’å–å¾—
            getLineVariables(lineNumber) {
                return this.lineToVariables.get(lineNumber) || [];
            }

            // å¤‰æ•°ã®å±¥æ­´ã‚’å–å¾—
            getVariableHistory(name) {
                return this.variableHistory.get(name) || [];
            }

            // ãƒªã‚»ãƒƒãƒˆ
            reset() {
                this.variables = {};
                this.variableHistory.clear();
                this.lineToVariables.clear();
            }
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°è¿½è·¡ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        let variableTracker = new VariableTracker();
        
        // ã‚³ãƒ¡ãƒ³ãƒˆçŠ¶æ…‹ç®¡ç†
        let isInMultiLineComment = false;
        
        // ã‚³ãƒ¡ãƒ³ãƒˆåˆ¤å®šé–¢æ•°
        function isCommentLine(line) {
            const trimmedLine = line.trim();
            
            // ç©ºè¡Œ
            if (!trimmedLine) {
                return true;
            }
            
            // 1è¡Œã‚³ãƒ¡ãƒ³ãƒˆï¼ˆ//ã§å§‹ã¾ã‚‹ï¼‰
            if (trimmedLine.startsWith('//')) {
                return true;
            }
            
            // è¤‡æ•°è¡Œã‚³ãƒ¡ãƒ³ãƒˆã®é–‹å§‹ã‚’ãƒã‚§ãƒƒã‚¯
            if (trimmedLine.includes('/*')) {
                isInMultiLineComment = true;
            }
            
            // è¤‡æ•°è¡Œã‚³ãƒ¡ãƒ³ãƒˆä¸­
            if (isInMultiLineComment) {
                // è¤‡æ•°è¡Œã‚³ãƒ¡ãƒ³ãƒˆã®çµ‚äº†ã‚’ãƒã‚§ãƒƒã‚¯
                if (trimmedLine.includes('*/')) {
                    isInMultiLineComment = false;
                    // */ã‚ˆã‚Šå¾Œã«ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã¯ã€ã‚³ãƒ¡ãƒ³ãƒˆè¡Œã§ã¯ãªã„
                    const afterComment = trimmedLine.substring(trimmedLine.indexOf('*/') + 2).trim();
                    return afterComment === '';
                }
                return true;
            }
            
            // è¡Œå†…ã«ã‚³ãƒ¡ãƒ³ãƒˆãŒã‚ã‚‹å ´åˆã€ã‚³ãƒ¡ãƒ³ãƒˆéƒ¨åˆ†ã‚’é™¤ã„ã¦åˆ¤å®š
            const commentIndex = trimmedLine.indexOf('//');
            if (commentIndex !== -1) {
                const beforeComment = trimmedLine.substring(0, commentIndex).trim();
                return beforeComment === '';
            }
            
            return false;
        }
        
        // ã‚³ãƒ¡ãƒ³ãƒˆé™¤å»é–¢æ•°ï¼ˆã‚³ãƒ¼ãƒ‰éƒ¨åˆ†ã®ã¿ã‚’æŠ½å‡ºï¼‰
        function removeComments(line) {
            const trimmedLine = line.trim();
            
            // è¤‡æ•°è¡Œã‚³ãƒ¡ãƒ³ãƒˆä¸­ã®å ´åˆ
            if (isInMultiLineComment) {
                if (trimmedLine.includes('*/')) {
                    isInMultiLineComment = false;
                    return trimmedLine.substring(trimmedLine.indexOf('*/') + 2).trim();
                }
                return '';
            }
            
            // è¡Œå†…ã‚³ãƒ¡ãƒ³ãƒˆã®å‡¦ç†
            let result = trimmedLine;
            
            // æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«å†…ã®ã‚³ãƒ¡ãƒ³ãƒˆè¨˜å·ã‚’ä¿è­·
            const stringMatches = [];
            result = result.replace(/"([^"]*)"/g, (match) => {
                stringMatches.push(match);
                return `__STRING_${stringMatches.length - 1}__`;
            });
            result = result.replace(/'([^']*)'/g, (match) => {
                stringMatches.push(match);
                return `__STRING_${stringMatches.length - 1}__`;
            });
            
            // ã‚³ãƒ¡ãƒ³ãƒˆéƒ¨åˆ†ã‚’å‰Šé™¤
            const commentIndex = result.indexOf('//');
            if (commentIndex !== -1) {
                result = result.substring(0, commentIndex).trim();
            }
            
            const multiCommentStart = result.indexOf('/*');
            if (multiCommentStart !== -1) {
                const multiCommentEnd = result.indexOf('*/', multiCommentStart);
                if (multiCommentEnd !== -1) {
                    result = result.substring(0, multiCommentStart) + result.substring(multiCommentEnd + 2);
                } else {
                    result = result.substring(0, multiCommentStart);
                    isInMultiLineComment = true;
                }
                result = result.trim();
            }
            
            // æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’å¾©å…ƒ
            stringMatches.forEach((str, index) => {
                result = result.replace(`__STRING_${index}__`, str);
            });
            
            return result;
        }

        // å¤‰æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®æ›´æ–°ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
        function updateVariableOverlay(lineNumber, variableName, value, changeType = 'assignment') {
            try {
                const overlay = document.getElementById(`overlay-line-${lineNumber}`);
                if (!overlay) return;
                
                // å€¤ã®å‹ã‚’åˆ¤å®š
                const valueType = getValueType(value);
                const typeIcon = getTypeIcon(valueType);
                const formattedValue = formatValueForDisplay(value, valueType);
            
            // æ—¢å­˜ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤å†…å®¹ã‚’å–å¾—
            const existingVars = overlay.textContent ? 
                overlay.textContent.split(' | ').filter(s => s.trim()) : [];
            
            // æ–°ã—ã„å¤‰æ•°æƒ…å ±ã‚’ä½œæˆï¼ˆå‹ã‚¢ã‚¤ã‚³ãƒ³ä»˜ãï¼‰
            const newVarDisplay = `${typeIcon} ${variableName}: ${formattedValue}`;
            
            // æ—¢å­˜ã®åŒåå¤‰æ•°ã‚’æ›´æ–°ã€ã¾ãŸã¯æ–°è¦è¿½åŠ 
            let found = false;
            const updatedVars = existingVars.map(varDisplay => {
                if (varDisplay.includes(`${variableName}:`)) {
                    found = true;
                    return newVarDisplay;
                }
                return varDisplay;
            });
            
            if (!found) {
                updatedVars.push(newVarDisplay);
            }
            
            // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ›´æ–°
            const newDisplay = updatedVars.join(' | ');
            const previousValue = overlay.textContent;
            
            if (previousValue !== newDisplay) {
                overlay.textContent = newDisplay;
                overlay.classList.add('visible');
                
                // å‹ã«å¿œã˜ãŸã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
                overlay.classList.remove('function-type', 'object-type', 'error-type');
                if (valueType === 'function') {
                    overlay.classList.add('function-type');
                } else if (valueType === 'object') {
                    overlay.classList.add('object-type');
                } else if (changeType === 'error') {
                    overlay.classList.add('error-type');
                }
                
                if (previousValue && previousValue !== '') {
                    // å€¤ãŒå¤‰åŒ–ã—ãŸå ´åˆã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    overlay.classList.remove('changed');
                    
                    const timeoutId1 = setTimeout(() => {
                        currentTimeouts.delete(timeoutId1);
                        overlay.classList.add('changed');
                    }, 10);
                    currentTimeouts.add(timeoutId1);
                    
                    const timeoutId2 = setTimeout(() => {
                        currentTimeouts.delete(timeoutId2);
                        overlay.classList.remove('changed');
                    }, 1500);
                    currentTimeouts.add(timeoutId2);
                }
            }
            } catch (e) {
                console.warn(`å¤‰æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤ºã‚¨ãƒ©ãƒ¼ (è¡Œ ${lineNumber}):`, e.message);
                // ã‚¨ãƒ©ãƒ¼æ™‚ã§ã‚‚åŸºæœ¬çš„ãªè¡¨ç¤ºã¯è©¦è¡Œ
                try {
                    const overlay = document.getElementById(`overlay-line-${lineNumber}`);
                    if (overlay) {
                        overlay.textContent = `${variableName}: [ã‚¨ãƒ©ãƒ¼]`;
                        overlay.classList.add('visible', 'error-type');
                    }
                } catch (fallbackError) {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚‚å¤±æ•—ã—ãŸå ´åˆã¯ç„¡è¦–
                }
            }
        }
        
        // å€¤ã®å‹ã‚’åˆ¤å®š
        function getValueType(value) {
            if (value === null) return 'null';
            if (value === undefined) return 'undefined';
            if (typeof value === 'function') return 'function';
            if (Array.isArray(value)) return 'array';
            if (typeof value === 'object') return 'object';
            if (typeof value === 'string') return 'string';
            if (typeof value === 'number') return 'number';
            if (typeof value === 'boolean') return 'boolean';
            return 'unknown';
        }
        
        // å‹ã«å¿œã˜ãŸã‚¢ã‚¤ã‚³ãƒ³ã‚’å–å¾—
        function getTypeIcon(type) {
            const icons = {
                'string': 'ğŸ“',
                'number': 'ğŸ”¢',
                'boolean': 'âœ…',
                'array': 'ğŸ“‹',
                'object': 'ğŸ“¦',
                'function': 'âš™ï¸',
                'null': 'ğŸš«',
                'undefined': 'â“',
                'unknown': 'â”'
            };
            return icons[type] || 'â”';
        }
        
        // è¡¨ç¤ºç”¨ã®å€¤ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        function formatValueForDisplay(value, type) {
            if (value === null) return 'null';
            if (value === undefined) return 'undefined';
            
            switch (type) {
                case 'string':
                    return `"${value.length > 30 ? value.substring(0, 30) + '...' : value}"`;
                case 'array':
                    // é…åˆ—ã®è¦ç´ ã‚’å®Ÿéš›ã«è¡¨ç¤ºï¼ˆé•·ã•åˆ¶é™ä»˜ãï¼‰
                    if (value.length <= 10) {
                        return `[${value.join(', ')}]`;
                    } else {
                        return `[${value.slice(0, 5).join(', ')}, ...${value.length}å€‹]`;
                    }
                case 'object':
                    const keys = Object.keys(value);
                    return `{${keys.length}å€‹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£}`;
                case 'function':
                    return value.name ? `${value.name}()` : 'function()';
                case 'number':
                    return value.toString();
                case 'boolean':
                    return value ? 'true' : 'false';
                default:
                    return JSON.stringify(value);
            }
        }

        // è¤‡æ•°å¤‰æ•°ã‚’åŒæ™‚ã«æ›´æ–°
        function updateMultipleVariableOverlays(lineNumber, variables) {
            const overlay = document.getElementById(`overlay-line-${lineNumber}`);
            if (!overlay) return;
            
            const varDisplays = variables.map(v => 
                `${v.name}: ${JSON.stringify(v.value)}`
            );
            
            const newDisplay = varDisplays.join(' | ');
            const previousValue = overlay.textContent;
            
            if (previousValue !== newDisplay) {
                overlay.textContent = newDisplay;
                overlay.classList.add('visible');
                
                if (previousValue && previousValue !== '') {
                    overlay.classList.remove('changed');
                    
                    const timeoutId1 = setTimeout(() => {
                        currentTimeouts.delete(timeoutId1);
                        overlay.classList.add('changed');
                    }, 10);
                    currentTimeouts.add(timeoutId1);
                    
                    const timeoutId2 = setTimeout(() => {
                        currentTimeouts.delete(timeoutId2);
                        overlay.classList.remove('changed');
                    }, 1500);
                    currentTimeouts.add(timeoutId2);
                }
            }
        }

        // å¤‰æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®ãƒªã‚»ãƒƒãƒˆ
        function resetVariableOverlays() {
            document.querySelectorAll('.variable-overlay').forEach(overlay => {
                overlay.textContent = '';
                overlay.classList.remove('visible', 'changed');
            });
        }

        // ã‚¨ãƒ©ãƒ¼ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
        class ErrorManager {
            constructor() {
                this.errors = [];
                this.warnings = [];
                this.debugInfo = [];
            }
            
            logError(message, lineNumber, context = {}) {
                const error = {
                    type: 'error',
                    message: message,
                    lineNumber: lineNumber,
                    timestamp: new Date().toISOString(),
                    context: context
                };
                this.errors.push(error);
                this.displayError(error);
                return error;
            }
            
            logWarning(message, lineNumber, context = {}) {
                const warning = {
                    type: 'warning',
                    message: message,
                    lineNumber: lineNumber,
                    timestamp: new Date().toISOString(),
                    context: context
                };
                this.warnings.push(warning);
                this.displayWarning(warning);
                return warning;
            }
            
            logDebug(message, lineNumber, data = {}) {
                const debug = {
                    type: 'debug',
                    message: message,
                    lineNumber: lineNumber,
                    timestamp: new Date().toISOString(),
                    data: data
                };
                this.debugInfo.push(debug);
                // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã¯é€šå¸¸è¡¨ç¤ºã—ãªã„ï¼ˆé–‹ç™ºè€…ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿ï¼‰
                return debug;
            }
            
            displayError(error) {
                const errorMsg = `ğŸš« è¡Œ${error.lineNumber}: ${error.message}`;
                if (error.context && Object.keys(error.context).length > 0) {
                    const contextMsg = `   è©³ç´°: ${JSON.stringify(error.context, null, 2)}`;
                    addConsoleOutput(errorMsg, 'error');
                    addConsoleOutput(contextMsg, 'error');
                } else {
                    addConsoleOutput(errorMsg, 'error');
                }
            }
            
            displayWarning(warning) {
                const warningMsg = `âš ï¸ è¡Œ${warning.lineNumber}: ${warning.message}`;
                addConsoleOutput(warningMsg, 'warning');
            }
            
            clear() {
                this.errors = [];
                this.warnings = [];
                this.debugInfo = [];
            }
            
            getErrorSummary() {
                return {
                    errorCount: this.errors.length,
                    warningCount: this.warnings.length,
                    debugCount: this.debugInfo.length,
                    lastError: this.errors.length > 0 ? this.errors[this.errors.length - 1] : null
                };
            }
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒãƒ¼ã‚¸ãƒ£
        let errorManager = new ErrorManager();

        // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›
        function addConsoleOutput(message, type = 'normal') {
            const console = document.getElementById('outputConsole');
            const line = document.createElement('div');
            line.className = `console-line ${type}`;
            line.textContent = message;
            console.appendChild(line);
            scrollOutputToBottom();
        }

        // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚¯ãƒªã‚¢
        function clearConsole(showPlaceholder = true) {
            const console = document.getElementById('outputConsole');
            if (showPlaceholder) {
                console.innerHTML = '<div class="console-line">ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...</div>';
            } else {
                console.innerHTML = '';
            }
        }

        // é€Ÿåº¦è¨­å®š
        function setSpeed(speed) {
            animationSpeed = speed;
            document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        // å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰å¤‰æ›´
        function onExecutionModeChange() {
            const selectedMode = document.querySelector('input[name="executionMode"]:checked').value;
            executionMode = selectedMode;
            updateExecutionModeUI();
        }

        // å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ãŸUIè¡¨ç¤ºæ›´æ–°
        function updateExecutionModeUI() {
            const stepInfo = document.getElementById('stepInfo');
            const nextStepBtn = document.getElementById('nextStepBtn');
            
            if (executionMode === 'step') {
                if (isProcessing) {
                    stepInfo.style.display = 'block';
                    nextStepBtn.style.display = 'inline-block';
                }
            } else {
                stepInfo.style.display = 'none';
                nextStepBtn.style.display = 'none';
            }
        }

        // ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œï¼šæ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¾ã§å¾…æ©Ÿ
        function waitForNextStep() {
            return new Promise((resolve, reject) => {
                // å®Ÿè¡ŒãŒä¸­æ–­ã•ã‚ŒãŸå ´åˆã¯å³åº§ã«ãƒªã‚¸ã‚§ã‚¯ãƒˆ
                if (executionAborted) {
                    reject(new Error('å®Ÿè¡ŒãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸ'));
                    return;
                }
                
                if (!stepWaiting) {
                    resolve();
                    return;
                }
                
                nextStepResolve = resolve;
                updateStepButton();
            });
        }

        // é€šå¸¸ã®ã‚¿ã‚¤ãƒãƒ¼ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ï¼‰
        function animationDelay(duration) {
            return new Promise((resolve, reject) => {
                // å®Ÿè¡ŒãŒä¸­æ–­ã•ã‚ŒãŸå ´åˆã¯å³åº§ã«ãƒªã‚¸ã‚§ã‚¯ãƒˆ
                if (executionAborted) {
                    reject(new Error('å®Ÿè¡ŒãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸ'));
                    return;
                }
                
                const timeoutId = setTimeout(() => {
                    currentTimeouts.delete(timeoutId);
                    
                    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå®Ÿè¡Œæ™‚ã«ã‚‚ä¸­æ–­ãƒ•ãƒ©ã‚°ã‚’ãƒã‚§ãƒƒã‚¯
                    if (executionAborted) {
                        reject(new Error('å®Ÿè¡ŒãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸ'));
                    } else {
                        resolve();
                    }
                }, duration / animationSpeed);
                
                // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆIDã‚’è¿½è·¡
                currentTimeouts.add(timeoutId);
            });
        }

        // æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã«é€²ã‚€
        function nextStep() {
            if (nextStepResolve) {
                const resolveFunc = nextStepResolve;
                nextStepResolve = null;
                currentStep++;
                updateStepDisplay();
                resolveFunc();
            }
        }

        // ã‚¹ãƒ†ãƒƒãƒ—ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºæ›´æ–°
        function updateStepButton() {
            const stepBtn = document.getElementById('nextStepBtn');
            if (stepBtn && stepWaiting) {
                stepBtn.disabled = false;
                if (currentStep < totalSteps - 1) {
                    stepBtn.textContent = `â–¶ï¸ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ— (${currentStep + 1}/${totalSteps})`;
                } else {
                    stepBtn.textContent = 'ğŸ å®Ÿè¡Œå®Œäº†';
                }
            }
        }

        // ã‚¹ãƒ†ãƒƒãƒ—è¡¨ç¤ºã®æ›´æ–°
        function updateStepDisplay() {
            const stepCounter = document.querySelector('.step-counter');
            if (stepCounter) {
                stepCounter.textContent = `ã‚¹ãƒ†ãƒƒãƒ— ${currentStep}/${totalSteps}`;
            }
        }

        // å®Ÿè¡Œå‡¦ç†ã®ãƒ¡ã‚¤ãƒ³é–¢æ•°
        async function startExecution() {
            if (isProcessing) {
                return;
            }
            
            const code = document.getElementById('codeInput').value.trim();
            if (!code) {
                addConsoleOutput('ã‚¨ãƒ©ãƒ¼: ã‚³ãƒ¼ãƒ‰ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                return;
            }
            
            // å®Ÿè¡Œãƒ•ãƒ©ã‚°ã‚’åˆæœŸåŒ–ï¼ˆå³åº§ã«ãƒªã‚»ãƒƒãƒˆï¼‰
            executionAborted = false;
            
            // å®Ÿè¡Œçµæœãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º
            showOutputPanel();
            
            // æ—¢å­˜ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚¯ãƒªã‚¢
            currentTimeouts.forEach(timeoutId => {
                clearTimeout(timeoutId);
            });
            currentTimeouts.clear();
            
            isProcessing = true;
            currentStep = 0;
            nextStepResolve = null;
            
            // å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦å‡¦ç†ã‚’åˆ†å²
            if (executionMode === 'step') {
                stepWaiting = true;
            } else {
                stepWaiting = false;
            }
            
            document.getElementById('executeBtn').disabled = true;
            
            // å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦UIè¡¨ç¤ºã‚’è¨­å®š
            if (executionMode === 'step') {
                document.getElementById('nextStepBtn').style.display = 'inline-block';
                document.getElementById('stepInfo').style.display = 'block';
                updateStepDisplay();
                updateStepButton();
            } else {
                document.getElementById('nextStepBtn').style.display = 'none';
                document.getElementById('stepInfo').style.display = 'none';
            }
            
            resetExecution(false);
            clearConsole(false); // å®Ÿè¡Œé–‹å§‹æ™‚ã«ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’å®Œå…¨ã«ã‚¯ãƒªã‚¢
            
            try {
                totalSteps = codeLines.length;
                await executeCodeStepByStep(code);
                
                // æ­£å¸¸çµ‚äº†ã®å ´åˆ
                if (!executionAborted) {
                    addConsoleOutput('å®Ÿè¡Œå®Œäº†', 'normal');
                }
                
            } catch (error) {
                // ä¸­æ–­ã‚¨ãƒ©ãƒ¼ã¯ç‰¹åˆ¥ã«å‡¦ç†
                if (error.message === 'å®Ÿè¡ŒãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸ') {
                    addConsoleOutput('å®Ÿè¡ŒãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸ', 'warning');
                } else {
                    addConsoleOutput('å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                }
            } finally {
                // å®Ÿè¡Œçµ‚äº†æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                isProcessing = false;
                stepWaiting = false;
                nextStepResolve = null;
                currentStep = 0;
                
                document.getElementById('executeBtn').disabled = false;
                document.getElementById('nextStepBtn').style.display = 'none';
                document.getElementById('stepInfo').style.display = 'none';
                
                // å…¨ã¦ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚¯ãƒªã‚¢
                currentTimeouts.forEach(timeoutId => {
                    clearTimeout(timeoutId);
                });
                currentTimeouts.clear();
            }
        }

        // é«˜åº¦ãªã‚³ãƒ¼ãƒ‰è§£ææ©Ÿèƒ½
        class CodeAnalyzer {
            constructor(variableTracker, globalVariables) {
                this.variableTracker = variableTracker;
                this.variables = {};
                this.globalVariables = globalVariables;
                this.lineToVarMap = new Map();
                this.loopStack = [];
                this.loopCounters = new Map();
                this.functions = new Map(); // é–¢æ•°å®šç¾©ã‚’ä¿å­˜
                this.scopeStack = []; // ã‚¹ã‚³ãƒ¼ãƒ—ã‚¹ã‚¿ãƒƒã‚¯
                this.callStack = []; // é–¢æ•°å‘¼ã³å‡ºã—ã‚¹ã‚¿ãƒƒã‚¯
                this.currentScope = { variables: {}, parent: null, type: 'global' };
                this.breakFlag = false; // breakæ–‡ãƒ•ãƒ©ã‚°
                this.continueFlag = false; // continueæ–‡ãƒ•ãƒ©ã‚°
                this.returnFlag = false; // returnæ–‡ãƒ•ãƒ©ã‚°
                this.returnValue = undefined; // returnå€¤
            }
            
            // ã‚¹ã‚³ãƒ¼ãƒ—ç®¡ç†ãƒ¡ã‚½ãƒƒãƒ‰
            pushScope(type = 'block', name = null) {
                const newScope = {
                    variables: {},
                    parent: this.currentScope,
                    type: type,
                    name: name
                };
                this.scopeStack.push(this.currentScope);
                this.currentScope = newScope;
                return newScope;
            }
            
            popScope() {
                if (this.scopeStack.length > 0) {
                    this.currentScope = this.scopeStack.pop();
                }
            }
            
            // å¤‰æ•°ã‚’è¨­å®šï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ã‚’è€ƒæ…®ï¼‰
            setVariable(name, value, lineNumber, changeType = 'assignment', declType = null) {
                let targetScope = this.currentScope;
                
                // å®£è¨€ã®å ´åˆã¯ç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«è¿½åŠ 
                if (declType === 'let' || declType === 'const' || declType === 'var') {
                    // varã®å ´åˆã¯é–¢æ•°ã‚¹ã‚³ãƒ¼ãƒ—ã¾ãŸã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«è¿½åŠ 
                    if (declType === 'var') {
                        while (targetScope.parent && targetScope.type !== 'function' && targetScope.type !== 'global') {
                            targetScope = targetScope.parent;
                        }
                    }
                    targetScope.variables[name] = { value, type: declType, constant: declType === 'const' };
                } else {
                    // ä»£å…¥ã®å ´åˆã¯ã€å¤‰æ•°ãŒå­˜åœ¨ã™ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æ¢ã™
                    let searchScope = this.currentScope;
                    let found = false;
                    while (searchScope) {
                        if (searchScope.variables[name]) {
                            // constå¤‰æ•°ã¸ã®å†ä»£å…¥ãƒã‚§ãƒƒã‚¯
                            if (searchScope.variables[name].constant) {
                                throw new Error(`å®šæ•° ${name} ã«å†ä»£å…¥ã¯ã§ãã¾ã›ã‚“`);
                            }
                            searchScope.variables[name].value = value;
                            found = true;
                            break;
                        }
                        searchScope = searchScope.parent;
                    }
                    
                    // å¤‰æ•°ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«è¿½åŠ ï¼ˆvarã®å‹•ä½œï¼‰
                    if (!found) {
                        let globalScope = this.currentScope;
                        while (globalScope.parent) {
                            globalScope = globalScope.parent;
                        }
                        globalScope.variables[name] = { value, type: 'var', constant: false };
                    }
                }
                
                // å¾“æ¥ã®ã‚·ã‚¹ãƒ†ãƒ ã¨ã®äº’æ›æ€§ã®ãŸã‚
                this.variables[name] = value;
                this.globalVariables[name] = value;
                this.variableTracker.setVariable(name, value, lineNumber, changeType);
                
                return { varName: name, value, type: changeType };
            }
            
            // å¤‰æ•°ã‚’å–å¾—ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ãƒã‚§ãƒ¼ãƒ³ã‚’æ¤œç´¢ï¼‰
            getVariable(name) {
                let searchScope = this.currentScope;
                while (searchScope) {
                    if (searchScope.variables[name]) {
                        return searchScope.variables[name].value;
                    }
                    searchScope = searchScope.parent;
                }
                // å¾“æ¥ã®ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰ã‚‚æ¤œç´¢
                return this.variables[name];
            }
            
            // å¤‰æ•°åŒæœŸï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‹ã‚‰ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‚’æ›´æ–°ï¼‰
            syncFromGlobal() {
                for (const [name, value] of Object.entries(this.globalVariables)) {
                    this.variables[name] = value;
                }
            }
            
            // å¤‰æ•°åŒæœŸï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã‹ã‚‰ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’æ›´æ–°ï¼‰
            syncToGlobal() {
                for (const [name, value] of Object.entries(this.variables)) {
                    this.globalVariables[name] = value;
                }
            }

            // æ”¹è‰¯ã•ã‚ŒãŸå®‰å…¨ãªå¼è©•ä¾¡ï¼ˆevalã‚’ä½¿ã‚ãªã„ï¼‰
            safeEval(expression, context = null) {
                try {
                    const ctx = context || this.getAllVariablesFromScope();
                    return this.evaluateExpression(expression.trim(), ctx);
                } catch (e) {
                    throw new Error(`å¼ã®è©•ä¾¡ã‚¨ãƒ©ãƒ¼: ${e.message}`);
                }
            }
            
            // ã™ã¹ã¦ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å¤‰æ•°ã‚’åé›†
            getAllVariablesFromScope() {
                const allVars = {};
                let searchScope = this.currentScope;
                while (searchScope) {
                    for (const [name, varInfo] of Object.entries(searchScope.variables)) {
                        if (!(name in allVars)) {
                            allVars[name] = varInfo.value;
                        }
                    }
                    searchScope = searchScope.parent;
                }
                // å¾“æ¥ã‚·ã‚¹ãƒ†ãƒ ã®å¤‰æ•°ã‚‚è¿½åŠ 
                for (const [name, value] of Object.entries(this.variables)) {
                    if (!(name in allVars)) {
                        allVars[name] = value;
                    }
                }
                return allVars;
            }
            
            // å¼ã‚’è©•ä¾¡ï¼ˆå†å¸°çš„ã«å‡¦ç†ï¼‰
            evaluateExpression(expr, context) {
                expr = expr.trim();
                
                // æœ«å°¾ã®ã‚»ãƒŸã‚³ãƒ­ãƒ³ã‚’é™¤å»
                if (expr.endsWith(';')) {
                    expr = expr.slice(0, -1).trim();
                }
                
                // ãƒªãƒ†ãƒ©ãƒ«å€¤
                if (expr === 'true') return true;
                if (expr === 'false') return false;
                if (expr === 'null') return null;
                if (expr === 'undefined') return undefined;
                
                // æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ï¼ˆã‚»ãƒŸã‚³ãƒ­ãƒ³é™¤å»å¾Œï¼‰
                if (/^-?\d+(\.\d+)?$/.test(expr)) {
                    return parseFloat(expr);
                }
                
                // æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«
                if ((expr.startsWith('"') && expr.endsWith('"')) || 
                    (expr.startsWith("'") && expr.endsWith("'"))) {
                    return expr.slice(1, -1);
                }
                
                // é…åˆ—ãƒªãƒ†ãƒ©ãƒ«
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const arrayContent = expr.slice(1, -1).trim();
                    if (!arrayContent) return [];
                    
                    const elements = this.parseCommaSeparated(arrayContent);
                    return elements.map(el => this.evaluateExpression(el, context));
                }
                
                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ†ãƒ©ãƒ«ï¼ˆåŸºæœ¬çš„ãªå¯¾å¿œï¼‰
                if (expr.startsWith('{') && expr.endsWith('}')) {
                    const objContent = expr.slice(1, -1).trim();
                    if (!objContent) return {};
                    
                    const obj = {};
                    const properties = this.parseCommaSeparated(objContent);
                    for (const prop of properties) {
                        const colonIndex = prop.indexOf(':');
                        if (colonIndex !== -1) {
                            const key = prop.substring(0, colonIndex).trim();
                            const value = prop.substring(colonIndex + 1).trim();
                            const cleanKey = key.replace(/["']/g, '');
                            obj[cleanKey] = this.evaluateExpression(value, context);
                        }
                    }
                    return obj;
                }
                
                // å¤‰æ•°å‚ç…§
                if (/^\w+$/.test(expr)) {
                    if (expr in context) {
                        return context[expr];
                    }
                    throw new Error(`æœªå®šç¾©ã®å¤‰æ•°: ${expr}`);
                }
                
                // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆãƒ‰ãƒƒãƒˆè¨˜æ³•ï¼‰
                if (expr.includes('.')) {
                    const parts = expr.split('.');
                    let result = context[parts[0]];
                    if (result === undefined) {
                        throw new Error(`æœªå®šç¾©ã®å¤‰æ•°: ${parts[0]}`);
                    }
                    
                    for (let i = 1; i < parts.length; i++) {
                        if (result && typeof result === 'object') {
                            result = result[parts[i]];
                        } else {
                            throw new Error(`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“: ${parts[i]}`);
                        }
                    }
                    return result;
                }
                
                // é…åˆ—ã‚¢ã‚¯ã‚»ã‚¹
                if (expr.includes('[') && expr.includes(']')) {
                    const bracketIndex = expr.indexOf('[');
                    const varName = expr.substring(0, bracketIndex);
                    const indexExpr = expr.substring(bracketIndex + 1, expr.lastIndexOf(']'));
                    
                    const arrayValue = context[varName];
                    const index = this.evaluateExpression(indexExpr, context);
                    
                    if (Array.isArray(arrayValue) || typeof arrayValue === 'object') {
                        return arrayValue[index];
                    }
                    throw new Error(`é…åˆ—ã¾ãŸã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: ${varName}`);
                }
                
                // ç®—è¡“æ¼”ç®—å­ã®å‡¦ç†
                return this.evaluateArithmeticExpression(expr, context);
            }
            
            // ç®—è¡“å¼ã®è©•ä¾¡
            evaluateArithmeticExpression(expr, context) {
                // æ‹¬å¼§ã®å‡¦ç†
                while (expr.includes('(')) {
                    const innerExpr = this.extractParentheses(expr);
                    const result = this.evaluateExpression(innerExpr.content, context);
                    expr = expr.replace(innerExpr.full, String(result));
                }
                
                // æ¼”ç®—å­ã®å„ªå…ˆé †ä½ã«å¾“ã£ã¦è©•ä¾¡
                const operators = [
                    ['||'],
                    ['&&'],
                    ['==', '!=', '===', '!=='],
                    ['<', '>', '<=', '>='],
                    ['+', '-'],
                    ['*', '/', '%']
                ];
                
                for (const opGroup of operators) {
                    for (const op of opGroup) {
                        const opIndex = this.findOperator(expr, op);
                        if (opIndex !== -1) {
                            const left = expr.substring(0, opIndex).trim();
                            const right = expr.substring(opIndex + op.length).trim();
                            
                            const leftVal = this.evaluateExpression(left, context);
                            const rightVal = this.evaluateExpression(right, context);
                            
                            return this.applyOperator(leftVal, op, rightVal);
                        }
                    }
                }
                
                // å˜é …æ¼”ç®—å­
                if (expr.startsWith('!')) {
                    return !this.evaluateExpression(expr.substring(1), context);
                }
                if (expr.startsWith('-')) {
                    return -this.evaluateExpression(expr.substring(1), context);
                }
                if (expr.startsWith('+')) {
                    return +this.evaluateExpression(expr.substring(1), context);
                }
                
                throw new Error(`è©•ä¾¡ã§ããªã„å¼: ${expr}`);
            }
            
            // ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã®è¦ç´ ã‚’ãƒ‘ãƒ¼ã‚¹
            parseCommaSeparated(str) {
                const elements = [];
                let current = '';
                let depth = 0;
                let inString = false;
                let stringChar = '';
                
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    
                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                    } else if (inString && char === stringChar) {
                        inString = false;
                    } else if (!inString) {
                        if (char === '(' || char === '[' || char === '{') {
                            depth++;
                        } else if (char === ')' || char === ']' || char === '}') {
                            depth--;
                        } else if (char === ',' && depth === 0) {
                            elements.push(current.trim());
                            current = '';
                            continue;
                        }
                    }
                    
                    current += char;
                }
                
                if (current.trim()) {
                    elements.push(current.trim());
                }
                
                return elements;
            }
            
            // æ‹¬å¼§å†…ã®å¼ã‚’æŠ½å‡º
            extractParentheses(expr) {
                const start = expr.indexOf('(');
                let depth = 1;
                let end = start + 1;
                
                while (end < expr.length && depth > 0) {
                    if (expr[end] === '(') depth++;
                    if (expr[end] === ')') depth--;
                    end++;
                }
                
                return {
                    full: expr.substring(start, end),
                    content: expr.substring(start + 1, end - 1)
                };
            }
            
            // æ¼”ç®—å­ã®ä½ç½®ã‚’æ¤œç´¢
            findOperator(expr, operator) {
                let depth = 0;
                let inString = false;
                let stringChar = '';
                
                for (let i = expr.length - operator.length; i >= 0; i--) {
                    const char = expr[i];
                    
                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                    } else if (inString && char === stringChar) {
                        inString = false;
                    } else if (!inString) {
                        if (char === ')' || char === ']' || char === '}') {
                            depth++;
                        } else if (char === '(' || char === '[' || char === '{') {
                            depth--;
                        } else if (depth === 0 && expr.substring(i, i + operator.length) === operator) {
                            return i;
                        }
                    }
                }
                
                return -1;
            }
            
            // æ¼”ç®—å­ã‚’é©ç”¨
            applyOperator(left, operator, right) {
                switch (operator) {
                    case '+': return left + right;
                    case '-': return left - right;
                    case '*': return left * right;
                    case '/': return left / right;
                    case '%': return left % right;
                    case '==': return left == right;
                    case '!=': return left != right;
                    case '===': return left === right;
                    case '!==': return left !== right;
                    case '<': return left < right;
                    case '>': return left > right;
                    case '<=': return left <= right;
                    case '>=': return left >= right;
                    case '&&': return left && right;
                    case '||': return left || right;
                    default: throw new Error(`æœªå¯¾å¿œã®æ¼”ç®—å­: ${operator}`);
                }
            }

            // å¤‰æ•°å®£è¨€ã®è§£æï¼ˆè¤‡æ•°è¡Œå¯¾å¿œï¼‰
            parseVariableDeclaration(line, lineNumber, allLines, currentLineIndex) {
                // å˜ä¸€è¡Œã®å ´åˆ
                const singleLinePatterns = [
                    /^\s*(let|var|const)\s+(\w+)\s*=\s*(.+);?\s*$/,
                    /^\s*(let|var|const)\s+(\w+)\s*;\s*$/
                ];
                
                for (const pattern of singleLinePatterns) {
                    const match = line.match(pattern);
                    if (match) {
                        const varType = match[1];
                        const varName = match[2];
                        const varValue = match[3];
                        
                        let value = undefined;
                        if (varValue) {
                            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„é…åˆ—ã®é–‹å§‹ã‚’ãƒã‚§ãƒƒã‚¯
                            if (varValue.trim() === '{' || varValue.trim().startsWith('{') && !varValue.trim().endsWith('}')) {
                                // è¤‡æ•°è¡Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆ
                                const objResult = this.parseMultiLineObject(allLines, currentLineIndex, varValue);
                                if (objResult) {
                                    try {
                                        value = this.safeEval(objResult.fullExpression);
                                    } catch (e) {
                                        value = objResult.fullExpression;
                                    }
                                    // çµ±ä¸€ã•ã‚ŒãŸå¤‰æ•°è¨­å®šãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨
                                    const result = this.setVariable(varName, value, lineNumber, 'declaration', varType);
                                    this.lineToVarMap.set(lineNumber, { name: varName, value: value, type: 'declaration' });
                                    return { varName, value, type: varType, endLine: objResult.endLine };
                                }
                            } else if (varValue.trim() === '[' || varValue.trim().startsWith('[') && !varValue.trim().endsWith(']')) {
                                // è¤‡æ•°è¡Œé…åˆ—ã®å ´åˆ
                                const arrResult = this.parseMultiLineArray(allLines, currentLineIndex, varValue);
                                if (arrResult) {
                                    try {
                                        value = this.safeEval(arrResult.fullExpression);
                                    } catch (e) {
                                        value = arrResult.fullExpression;
                                    }
                                    // çµ±ä¸€ã•ã‚ŒãŸå¤‰æ•°è¨­å®šãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨
                                    const result = this.setVariable(varName, value, lineNumber, 'declaration', varType);
                                    this.lineToVarMap.set(lineNumber, { name: varName, value: value, type: 'declaration' });
                                    return { varName, value, type: varType, endLine: arrResult.endLine };
                                }
                            } else {
                                // é€šå¸¸ã®å˜ä¸€è¡Œå‡¦ç†
                                try {
                                    // ã‚»ãƒŸã‚³ãƒ­ãƒ³ã‚’é™¤å»
                                    let cleanVarValue = varValue;
                                    if (cleanVarValue.endsWith(';')) {
                                        cleanVarValue = cleanVarValue.slice(0, -1).trim();
                                    }
                                    value = this.safeEval(cleanVarValue, this.variables);
                                } catch (e) {
                                    value = varValue; // è©•ä¾¡ã§ããªã„å ´åˆã¯æ–‡å­—åˆ—ã¨ã—ã¦ä¿å­˜
                                }
                            }
                        }
                        
                        // çµ±ä¸€ã•ã‚ŒãŸå¤‰æ•°è¨­å®šãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨
                        const result = this.setVariable(varName, value, lineNumber, 'declaration', varType);
                        this.lineToVarMap.set(lineNumber, { name: varName, value: value, type: 'declaration' });
                        return { varName, value, type: varType };
                    }
                }
                return null;
            }
            
            // è¤‡æ•°è¡Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ
            parseMultiLineObject(lines, startIndex, initialValue) {
                let braceCount = 0;
                let fullExpression = '';
                let endLine = startIndex;
                
                // æœ€åˆã®è¡Œã®å‡¦ç†
                const firstLine = lines[startIndex].trim();
                const equalIndex = firstLine.indexOf('=');
                if (equalIndex !== -1) {
                    fullExpression = firstLine.substring(equalIndex + 1).trim();
                } else {
                    fullExpression = initialValue;
                }
                
                // ãƒ–ãƒ¬ãƒ¼ã‚¹ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                for (const char of fullExpression) {
                    if (char === '{') braceCount++;
                    if (char === '}') braceCount--;
                }
                
                // æ—¢ã«å®Œäº†ã—ã¦ã„ã‚‹å ´åˆ
                if (braceCount === 0) {
                    return { fullExpression, endLine };
                }
                
                // è¤‡æ•°è¡Œã‚’çµåˆ
                for (let i = startIndex + 1; i < lines.length && braceCount > 0; i++) {
                    const line = lines[i].trim();
                    fullExpression += ' ' + line;
                    
                    for (const char of line) {
                        if (char === '{') braceCount++;
                        if (char === '}') braceCount--;
                    }
                    
                    endLine = i;
                    
                    if (braceCount === 0) break;
                }
                
                return braceCount === 0 ? { fullExpression, endLine } : null;
            }
            
            // è¤‡æ•°è¡Œé…åˆ—ã®è§£æ
            parseMultiLineArray(lines, startIndex, initialValue) {
                let bracketCount = 0;
                let fullExpression = '';
                let endLine = startIndex;
                
                // æœ€åˆã®è¡Œã®å‡¦ç†
                const firstLine = lines[startIndex].trim();
                const equalIndex = firstLine.indexOf('=');
                if (equalIndex !== -1) {
                    fullExpression = firstLine.substring(equalIndex + 1).trim();
                } else {
                    fullExpression = initialValue;
                }
                
                // æ‹¬å¼§ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                for (const char of fullExpression) {
                    if (char === '[') bracketCount++;
                    if (char === ']') bracketCount--;
                }
                
                // æ—¢ã«å®Œäº†ã—ã¦ã„ã‚‹å ´åˆ
                if (bracketCount === 0) {
                    return { fullExpression, endLine };
                }
                
                // è¤‡æ•°è¡Œã‚’çµåˆ
                for (let i = startIndex + 1; i < lines.length && bracketCount > 0; i++) {
                    const line = lines[i].trim();
                    fullExpression += ' ' + line;
                    
                    for (const char of line) {
                        if (char === '[') bracketCount++;
                        if (char === ']') bracketCount--;
                    }
                    
                    endLine = i;
                    
                    if (bracketCount === 0) break;
                }
                
                return bracketCount === 0 ? { fullExpression, endLine } : null;
            }
            
            // é–¢æ•°å®šç¾©ã®è§£æ
            parseFunctionDeclaration(line, lineNumber) {
                // functionåå‰(å¼•æ•°) ã®å½¢å¼
                const functionMatch = line.match(/^\s*function\s+(\w+)\s*\(([^)]*)\)\s*\{?\s*$/);
                if (functionMatch) {
                    const funcName = functionMatch[1];
                    const paramsStr = functionMatch[2].trim();
                    const params = paramsStr ? paramsStr.split(',').map(p => p.trim()) : [];
                    
                    // é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                    const functionObj = {
                        name: funcName,
                        params: params,
                        startLine: lineNumber,
                        endLine: null, // å¾Œã§è¨­å®š
                        body: [],
                        type: 'function'
                    };
                    
                    this.functions.set(funcName, functionObj);
                    
                    // é–¢æ•°åã‚’å¤‰æ•°ã¨ã—ã¦ç™»éŒ²
                    this.setVariable(funcName, functionObj, lineNumber, 'function_declaration');
                    
                    return { type: 'function_declaration', name: funcName, params: params };
                }
                
                // ã‚¢ãƒ­ãƒ¼é–¢æ•°ã®åŸºæœ¬å½¢: const name = (params) => { 
                const arrowMatch = line.match(/^\s*(let|var|const)\s+(\w+)\s*=\s*\(([^)]*)\)\s*=>\s*\{?\s*$/);
                if (arrowMatch) {
                    const varType = arrowMatch[1];
                    const funcName = arrowMatch[2];
                    const paramsStr = arrowMatch[3].trim();
                    const params = paramsStr ? paramsStr.split(',').map(p => p.trim()) : [];
                    
                    const functionObj = {
                        name: funcName,
                        params: params,
                        startLine: lineNumber,
                        endLine: null,
                        body: [],
                        type: 'arrow_function'
                    };
                    
                    this.functions.set(funcName, functionObj);
                    this.setVariable(funcName, functionObj, lineNumber, 'function_declaration', varType);
                    
                    return { type: 'arrow_function_declaration', name: funcName, params: params };
                }
                
                // å˜ä¸€å¼ã‚¢ãƒ­ãƒ¼é–¢æ•°: const name = (params) => expression
                const singleArrowMatch = line.match(/^\s*(let|var|const)\s+(\w+)\s*=\s*\(([^)]*)\)\s*=>\s*(.+);?\s*$/);
                if (singleArrowMatch) {
                    const varType = singleArrowMatch[1];
                    const funcName = singleArrowMatch[2];
                    const paramsStr = singleArrowMatch[3].trim();
                    const expression = singleArrowMatch[4].trim();
                    const params = paramsStr ? paramsStr.split(',').map(p => p.trim()) : [];
                    
                    const functionObj = {
                        name: funcName,
                        params: params,
                        startLine: lineNumber,
                        endLine: lineNumber,
                        body: [`return ${expression}`],
                        type: 'single_arrow_function'
                    };
                    
                    this.functions.set(funcName, functionObj);
                    this.setVariable(funcName, functionObj, lineNumber, 'function_declaration', varType);
                    
                    return { type: 'single_arrow_function_declaration', name: funcName, params: params, expression: expression };
                }
                
                return null;
            }
            
            // é–¢æ•°å‘¼ã³å‡ºã—ã®è§£æ
            parseFunctionCall(line, lineNumber) {
                // åŸºæœ¬çš„ãªé–¢æ•°å‘¼ã³å‡ºã—: functionName(args)
                const callMatch = line.match(/^\s*(\w+)\s*\(([^)]*)\)\s*;?\s*$/);
                if (callMatch) {
                    const funcName = callMatch[1];
                    const argsStr = callMatch[2].trim();
                    const args = argsStr ? this.parseCommaSeparated(argsStr) : [];
                    
                    return { type: 'function_call', name: funcName, args: args };
                }
                
                // å¤‰æ•°ã¸ã®ä»£å…¥: const result = functionName(args)
                const assignCallMatch = line.match(/^\s*(let|var|const)\s+(\w+)\s*=\s*(\w+)\s*\(([^)]*)\)\s*;?\s*$/);
                if (assignCallMatch) {
                    const varType = assignCallMatch[1];
                    const varName = assignCallMatch[2];
                    const funcName = assignCallMatch[3];
                    const argsStr = assignCallMatch[4].trim();
                    const args = argsStr ? this.parseCommaSeparated(argsStr) : [];
                    
                    return { type: 'function_call_assignment', varType: varType, varName: varName, funcName: funcName, args: args };
                }
                
                // æ—¢å­˜å¤‰æ•°ã¸ã®ä»£å…¥: variable = functionName(args)
                const varAssignCallMatch = line.match(/^\s*(\w+)\s*=\s*(\w+)\s*\(([^)]*)\)\s*;?\s*$/);
                if (varAssignCallMatch) {
                    const varName = varAssignCallMatch[1];
                    const funcName = varAssignCallMatch[2];
                    const argsStr = varAssignCallMatch[3].trim();
                    const args = argsStr ? this.parseCommaSeparated(argsStr) : [];
                    
                    return { type: 'function_call_var_assignment', varName: varName, funcName: funcName, args: args };
                }
                
                return null;
            }
            
            // é–¢æ•°ã‚’å®Ÿè¡Œ
            async executeFunction(funcName, args, lineNumber) {
                const func = this.functions.get(funcName);
                if (!func) {
                    throw new Error(`æœªå®šç¾©ã®é–¢æ•°: ${funcName}`);
                }
                
                // æ–°ã—ã„ã‚¹ã‚³ãƒ¼ãƒ—ã‚’ä½œæˆ
                const functionScope = this.pushScope('function', funcName);
                
                // å¼•æ•°ã‚’é–¢æ•°ã‚¹ã‚³ãƒ¼ãƒ—ã«è¨­å®š
                for (let i = 0; i < func.params.length; i++) {
                    const paramName = func.params[i];
                    const argValue = i < args.length ? args[i] : undefined;
                    
                    // å¼•æ•°ã®å€¤ã‚’è©•ä¾¡
                    let evaluatedArg;
                    try {
                        evaluatedArg = this.safeEval(argValue);
                    } catch (e) {
                        evaluatedArg = argValue;
                    }
                    
                    functionScope.variables[paramName] = { value: evaluatedArg, type: 'parameter', constant: false };
                }
                
                // é–¢æ•°å‘¼ã³å‡ºã—ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ 
                this.callStack.push({
                    name: funcName,
                    args: args,
                    startLine: lineNumber,
                    returnValue: undefined
                });
                
                let returnValue = undefined;
                
                try {
                    if (func.type === 'single_arrow_function') {
                        // å˜ä¸€å¼ã‚¢ãƒ­ãƒ¼é–¢æ•°ã®å ´åˆã€å¼ã‚’è©•ä¾¡ã—ã¦è¿”ã™
                        const expression = func.body[0].replace('return ', '');
                        returnValue = this.safeEval(expression);
                    } else {
                        // é€šå¸¸ã®é–¢æ•°ã®å ´åˆã€é–¢æ•°æœ¬ä½“ã‚’å®Ÿè¡Œ
                        // ã“ã‚Œã¯è¤‡é›‘ãªãŸã‚ã€åŸºæœ¬çš„ãªå‡¦ç†ã®ã¿å®Ÿè£…
                        returnValue = `[Function ${funcName} executed]`;
                    }
                } catch (e) {
                    throw new Error(`é–¢æ•° ${funcName} ã®å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ${e.message}`);
                } finally {
                    // ã‚¹ã‚³ãƒ¼ãƒ—ã¨ã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    this.popScope();
                    this.callStack.pop();
                }
                
                return returnValue;
            }
            
            // returnæ–‡ã®è§£æ
            parseReturn(line, lineNumber) {
                const returnMatch = line.match(/^\s*return(\s+(.+))?\s*;?\s*$/);
                if (returnMatch) {
                    const returnExpr = returnMatch[2];
                    let returnValue = undefined;
                    
                    if (returnExpr) {
                        try {
                            returnValue = this.safeEval(returnExpr.trim());
                        } catch (e) {
                            returnValue = returnExpr.trim();
                        }
                    }
                    
                    this.returnFlag = true;
                    this.returnValue = returnValue;
                    
                    return { type: 'return', value: returnValue };
                }
                return null;
            }

            // ä»£å…¥ã®è§£æ
            parseAssignment(line, lineNumber) {
                const patterns = [
                    /^\s*(\w+)\s*=\s*(.+);?\s*$/,
                    /^\s*(\w+)\s*(\+=|-=|\*=|\/=|%=)\s*(.+);?\s*$/,  // è¤‡åˆä»£å…¥æ¼”ç®—å­
                    /^\s*(\w+)\s*(\+\+|--)\s*;?\s*$/,
                    /^\s*(\+\+|--)(\w+)\s*;?\s*$/,
                    /^\s*(\w+)\[(.+)\]\s*=\s*(.+);?\s*$/  // é…åˆ—è¦ç´ ã¸ã®ä»£å…¥
                ];
                
                // é€šå¸¸ã®ä»£å…¥
                const assignMatch = line.match(patterns[0]);
                if (assignMatch) {
                    const varName = assignMatch[1];
                    let varValue = assignMatch[2].trim();
                    
                    // æœ«å°¾ã®ã‚»ãƒŸã‚³ãƒ­ãƒ³ã‚’é™¤å»
                    if (varValue.endsWith(';')) {
                        varValue = varValue.slice(0, -1).trim();
                    }
                    
                    try {
                        const value = this.safeEval(varValue, this.variables);
                        const result = this.setVariable(varName, value, lineNumber, 'assignment');
                        this.lineToVarMap.set(lineNumber, { name: varName, value: value, type: 'assignment' });
                        return result;
                    } catch (e) {
                        throw new Error(`ä»£å…¥ã‚¨ãƒ©ãƒ¼: ${e.message}`);
                    }
                }
                
                // è¤‡åˆä»£å…¥æ¼”ç®—å­ï¼ˆ+=, -=, *=, /=, %=ï¼‰
                const compoundMatch = line.match(patterns[1]);
                if (compoundMatch) {
                    const varName = compoundMatch[1];
                    const operator = compoundMatch[2];
                    let rightValue = compoundMatch[3].trim();
                    
                    // æœ«å°¾ã®ã‚»ãƒŸã‚³ãƒ­ãƒ³ã‚’é™¤å»
                    if (rightValue.endsWith(';')) {
                        rightValue = rightValue.slice(0, -1).trim();
                    }
                    
                    if (this.variables[varName] !== undefined) {
                        try {
                            const currentValue = this.variables[varName];
                            const rightVal = this.safeEval(rightValue, this.variables);
                            let newValue;
                            
                            switch (operator) {
                                case '+=':
                                    newValue = currentValue + rightVal;
                                    break;
                                case '-=':
                                    newValue = currentValue - rightVal;
                                    break;
                                case '*=':
                                    newValue = currentValue * rightVal;
                                    break;
                                case '/=':
                                    newValue = currentValue / rightVal;
                                    break;
                                case '%=':
                                    newValue = currentValue % rightVal;
                                    break;
                                default:
                                    throw new Error(`æœªå¯¾å¿œã®æ¼”ç®—å­: ${operator}`);
                            }
                            
                            const result = this.setVariable(varName, newValue, lineNumber, 'compound_assignment');
                            this.lineToVarMap.set(lineNumber, { name: varName, value: newValue, type: 'compound_assignment' });
                            return result;
                        } catch (e) {
                            throw new Error(`è¤‡åˆä»£å…¥ã‚¨ãƒ©ãƒ¼: ${e.message}`);
                        }
                    } else {
                        throw new Error(`æœªå®šç¾©ã®å¤‰æ•°: ${varName}`);
                    }
                }
                
                // ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ/ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
                // å¾Œç½®ï¼šå¤‰æ•°++, å¤‰æ•°--
                const postIncMatch = line.match(patterns[2]);
                if (postIncMatch) {
                    const varName = postIncMatch[1];
                    const operator = postIncMatch[2];
                    
                    if (this.variables[varName] !== undefined) {
                        const currentValue = this.variables[varName];
                        const newValue = operator === '++' ? currentValue + 1 : currentValue - 1;
                        const result = this.setVariable(varName, newValue, lineNumber, 'increment');
                        this.lineToVarMap.set(lineNumber, { name: varName, value: newValue, type: 'increment' });
                        return result;
                    } else {
                        throw new Error(`æœªå®šç¾©ã®å¤‰æ•°: ${varName}`);
                    }
                }
                
                // å‰ç½®ï¼š++å¤‰æ•°, --å¤‰æ•°
                const preIncMatch = line.match(patterns[3]);
                if (preIncMatch) {
                    const operator = preIncMatch[1];
                    const varName = preIncMatch[2];
                    
                    if (this.variables[varName] !== undefined) {
                        const currentValue = this.variables[varName];
                        const newValue = operator === '++' ? currentValue + 1 : currentValue - 1;
                        const result = this.setVariable(varName, newValue, lineNumber, 'increment');
                        this.lineToVarMap.set(lineNumber, { name: varName, value: newValue, type: 'increment' });
                        return result;
                    } else {
                        throw new Error(`æœªå®šç¾©ã®å¤‰æ•°: ${varName}`);
                    }
                }
                
                // é…åˆ—è¦ç´ ã¸ã®ä»£å…¥: arrayName[index] = value
                const arrayAssignMatch = line.match(patterns[4]);
                if (arrayAssignMatch) {
                    const arrayName = arrayAssignMatch[1];
                    const indexExpr = arrayAssignMatch[2];
                    const valueExpr = arrayAssignMatch[3].trim();
                    
                    if (this.variables[arrayName] !== undefined && Array.isArray(this.variables[arrayName])) {
                        try {
                            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è©•ä¾¡
                            const index = this.safeEval(indexExpr, this.variables);
                            // å€¤ã‚’è©•ä¾¡
                            const value = this.safeEval(valueExpr, this.variables);
                            
                            // é…åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆã—ã¦è¦ç´ ã‚’æ›´æ–°
                            const newArray = [...this.variables[arrayName]];
                            newArray[index] = value;
                            
                            // é…åˆ—å…¨ä½“ã‚’æ›´æ–°
                            const result = this.setVariable(arrayName, newArray, lineNumber, 'array_assignment');
                            this.lineToVarMap.set(lineNumber, { name: arrayName, value: newArray, type: 'array_assignment' });
                            return result;
                        } catch (e) {
                            throw new Error(`é…åˆ—è¦ç´ ä»£å…¥ã‚¨ãƒ©ãƒ¼: ${e.message}`);
                        }
                    } else {
                        throw new Error(`æœªå®šç¾©ã®é…åˆ—ã¾ãŸã¯é…åˆ—ã§ã¯ãªã„å¤‰æ•°: ${arrayName}`);
                    }
                }
                
                return null;
            }

            // console.log ã®è§£æ
            parseConsoleLog(line) {
                const match = line.match(/console\.log\s*\(\s*(.+)\s*\)/);
                if (match) {
                    const args = match[1];
                    try {
                        const result = this.safeEval(args, this.variables);
                        return String(result);
                    } catch (e) {
                        // è¤‡æ•°å¼•æ•°ã®å ´åˆã®ç°¡æ˜“å‡¦ç†
                        const parts = args.split('+').map(part => {
                            part = part.trim();
                            if (part.startsWith('"') && part.endsWith('"')) {
                                return part.slice(1, -1);
                            } else if (this.variables[part] !== undefined) {
                                return String(this.variables[part]);
                            } else {
                                return part;
                            }
                        });
                        return parts.join('');
                    }
                }
                return null;
            }

            // æ¡ä»¶åˆ†å²ã®è§£æï¼ˆæ”¹è‰¯ç‰ˆï¼‰
            parseCondition(line) {
                // ifæ–‡ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
                const ifMatch = line.match(/^\s*if\s*\(\s*(.+)\s*\)\s*\{?\s*$/);
                if (ifMatch) {
                    const condition = ifMatch[1];
                    try {
                        const result = this.safeEval(condition, this.variables);
                        return { type: 'if', condition: condition, result: Boolean(result) };
                    } catch (e) {
                        return { type: 'if', condition: condition, result: false, error: e.message };
                    }
                }
                
                // else ifæ–‡ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆè¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾å¿œï¼‰
                const elseIfPatterns = [
                    /^\s*}\s*else\s+if\s*\(\s*(.+)\s*\)\s*\{?\s*$/,  // } else if (condition) {
                    /^\s*else\s+if\s*\(\s*(.+)\s*\)\s*\{?\s*$/       // else if (condition) {
                ];
                
                for (const pattern of elseIfPatterns) {
                    const elseIfMatch = line.match(pattern);
                    if (elseIfMatch) {
                        const condition = elseIfMatch[1];
                        try {
                            const result = this.safeEval(condition, this.variables);
                            return { type: 'elseif', condition: condition, result: Boolean(result) };
                        } catch (e) {
                            return { type: 'elseif', condition: condition, result: false, error: e.message };
                        }
                    }
                }
                
                // elseæ–‡ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆè¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾å¿œï¼‰
                const elsePatterns = [
                    /^\s*}\s*else\s*\{?\s*$/,  // } else {
                    /^\s*else\s*\{?\s*$/       // else {
                ];
                
                for (const pattern of elsePatterns) {
                    if (line.match(pattern)) {
                        return { type: 'else' };
                    }
                }
                
                return null;
            }

            // ãƒ«ãƒ¼ãƒ—ã®è§£æ
            parseLoop(line) {
                const forMatch = line.match(/^\s*for\s*\(\s*(.+)\s*\)\s*\{?\s*$/);
                if (forMatch) {
                    const forParts = forMatch[1].split(';').map(part => part.trim());
                    if (forParts.length === 3) {
                        return {
                            type: 'for',
                            init: forParts[0],
                            condition: forParts[1],
                            increment: forParts[2]
                        };
                    }
                }
                
                const whileMatch = line.match(/^\s*while\s*\(\s*(.+)\s*\)\s*\{?\s*$/);
                if (whileMatch) {
                    return {
                        type: 'while',
                        condition: whileMatch[1]
                    };
                }
                
                const doWhileMatch = line.match(/^\s*do\s*\{?\s*$/);
                if (doWhileMatch) {
                    return {
                        type: 'do_while_start'
                    };
                }
                
                const doWhileEndMatch = line.match(/^\s*\}\s*while\s*\(\s*(.+)\s*\)\s*;?\s*$/);
                if (doWhileEndMatch) {
                    return {
                        type: 'do_while_end',
                        condition: doWhileEndMatch[1]
                    };
                }
                
                return null;
            }
            
            // switchæ–‡ã®è§£æ
            parseSwitch(line) {
                const switchMatch = line.match(/^\s*switch\s*\(\s*(.+)\s*\)\s*\{?\s*$/);
                if (switchMatch) {
                    return {
                        type: 'switch',
                        expression: switchMatch[1]
                    };
                }
                
                const caseMatch = line.match(/^\s*case\s+(.+)\s*:\s*$/);
                if (caseMatch) {
                    return {
                        type: 'case',
                        value: caseMatch[1]
                    };
                }
                
                const defaultMatch = line.match(/^\s*default\s*:\s*$/);
                if (defaultMatch) {
                    return {
                        type: 'default'
                    };
                }
                
                return null;
            }
            
            // åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼æ–‡ã®è§£æ
            parseControlFlow(line) {
                // breakæ–‡
                const breakMatch = line.match(/^\s*break\s*;?\s*$/);
                if (breakMatch) {
                    this.breakFlag = true;
                    return { type: 'break' };
                }
                
                // continueæ–‡
                const continueMatch = line.match(/^\s*continue\s*;?\s*$/);
                if (continueMatch) {
                    this.continueFlag = true;
                    return { type: 'continue' };
                }
                
                return null;
            }

            // forãƒ«ãƒ¼ãƒ—ã®åˆæœŸåŒ–å‡¦ç†
            executeForInit(initStatement, lineNumber) {
                let cleanStatement = initStatement.trim();
                if (cleanStatement.endsWith(';')) {
                    cleanStatement = cleanStatement.slice(0, -1).trim();
                }
                
                if (cleanStatement.includes('let ') || cleanStatement.includes('var ') || cleanStatement.includes('const ')) {
                    const result = this.parseVariableDeclaration(cleanStatement, lineNumber);
                    if (result) {
                        return result;
                    }
                } else if (cleanStatement.includes('=')) {
                    const result = this.parseAssignment(cleanStatement, lineNumber);
                    if (result) {
                        return result;
                    }
                }
                return null;
            }

            // ãƒ«ãƒ¼ãƒ—æ¡ä»¶ã®è©•ä¾¡
            evaluateLoopCondition(condition) {
                try {
                    // æ¡ä»¶å¼ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    let cleanCondition = condition.trim();
                    if (cleanCondition.endsWith(';')) {
                        cleanCondition = cleanCondition.slice(0, -1).trim();
                    }
                    return Boolean(this.safeEval(cleanCondition, this.variables));
                } catch (e) {
                    console.warn('ãƒ«ãƒ¼ãƒ—æ¡ä»¶ã®è©•ä¾¡ã‚¨ãƒ©ãƒ¼:', e.message);
                    return false; // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ«ãƒ¼ãƒ—ã‚’çµ‚äº†
                }
            }

            // forãƒ«ãƒ¼ãƒ—ã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆå®Ÿè¡Œ
            executeForIncrement(incrementStatement, lineNumber) {
                try {
                    let cleanStatement = incrementStatement.trim();
                    if (cleanStatement.endsWith(';')) {
                        cleanStatement = cleanStatement.slice(0, -1).trim();
                    }
                    
                    // ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ/ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆæ§‹æ–‡ã‚’å„ªå…ˆçš„ã«å‡¦ç†
                    const incMatch = cleanStatement.match(/(\w+)\s*(\+\+|--)/);
                    if (incMatch) {
                        const varName = incMatch[1];
                        const operator = incMatch[2];
                        
                        if (this.variables[varName] !== undefined) {
                            const currentValue = this.variables[varName];
                            const newValue = operator === '++' ? currentValue + 1 : currentValue - 1;
                            const result = this.setVariable(varName, newValue, lineNumber, 'increment');
                            return result;
                        }
                    }
                    
                    // é€šå¸¸ã®ä»£å…¥ãƒ‘ã‚¿ãƒ¼ãƒ³
                    const result = this.parseAssignment(cleanStatement, lineNumber);
                    if (result) {
                        return result;
                    }
                    
                } catch (e) {
                    console.warn('ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆå‡¦ç†ã‚¨ãƒ©ãƒ¼:', e.message);
                }
                return null;
            }
        }

        // ã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã«å®Ÿè¡Œ
        async function executeCodeStepByStep(code) {
            // ãƒªã‚»ãƒƒãƒˆ
            variableTracker.reset();
            isInMultiLineComment = false; // ã‚³ãƒ¡ãƒ³ãƒˆçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            const analyzer = new CodeAnalyzer(variableTracker, variables);
            const lines = code.split('\n');
            variables = {};
            
            // console.logã®ç½®ãæ›ãˆ
            const originalConsoleLog = console.log;
            console.log = function(...args) {
                addConsoleOutput(args.join(' '));
            };
            
            try {
                let lineIndex = 0;
                let conditionStack = []; // æ¡ä»¶åˆ†å²ã®ã‚¹ã‚¿ãƒƒã‚¯
                let loopStack = []; // ãƒ«ãƒ¼ãƒ—ã‚¹ã‚¿ãƒƒã‚¯
                let skipExecution = false; // å®Ÿè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã‹ã©ã†ã‹
                const MAX_LOOP_ITERATIONS = 1000; // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢
                
                while (lineIndex < lines.length) {
                    // å®Ÿè¡Œä¸­æ–­ãƒã‚§ãƒƒã‚¯
                    if (executionAborted) {
                        throw new Error('å®Ÿè¡ŒãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸ');
                    }
                    
                    const line = lines[lineIndex].trim();
                    const actualLineNumber = lineIndex + 1;
                    
                    // ç©ºè¡Œã‚„ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—
                    if (isCommentLine(line)) {
                        lineIndex++;
                        continue;
                    }
                    
                    // ã‚³ãƒ¡ãƒ³ãƒˆã‚’é™¤å»ã—ã¦ã‚³ãƒ¼ãƒ‰éƒ¨åˆ†ã®ã¿ã‚’å–å¾—
                    const codeOnly = removeComments(line);
                    if (!codeOnly) {
                        lineIndex++;
                        continue;
                    }
                    
                    await waitForNextStep();
                    highlightCodeLine(actualLineNumber, 800);
                    await animationDelay(800);
                    
                    try {
                        // ãƒ«ãƒ¼ãƒ—ã®å‡¦ç†
                        const loopResult = analyzer.parseLoop(codeOnly);
                        if (loopResult) {
                            if (loopResult.type === 'for') {
                                // forãƒ«ãƒ¼ãƒ—ã®å ´åˆã€ã™ã§ã«åˆæœŸåŒ–æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
                                const existingLoop = loopStack.find(loop => 
                                    loop.type === 'for' && loop.startLine === lineIndex
                                );
                                
                                if (!existingLoop) {
                                    // åˆå›ã®ã¿åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
                                    const initResult = analyzer.executeForInit(loopResult.init, actualLineNumber);
                                    if (initResult) {
                                        updateVariableOverlay(actualLineNumber, initResult.varName, initResult.value);
                                    }
                                    
                                    // ãƒ«ãƒ¼ãƒ—æƒ…å ±ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã«ãƒ—ãƒƒã‚·ãƒ¥
                                    loopStack.push({
                                        type: 'for',
                                        startLine: lineIndex,
                                        condition: loopResult.condition,
                                        increment: loopResult.increment,
                                        iterationCount: 0,
                                        initialized: true  // åˆæœŸåŒ–æ¸ˆã¿ãƒ•ãƒ©ã‚°
                                    });
                                }
                                
                                // ãƒ«ãƒ¼ãƒ—æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
                                const conditionResult = analyzer.evaluateLoopCondition(loopResult.condition);
                                if (!conditionResult) {
                                    // æ¡ä»¶ãŒå½ã®å ´åˆã€ãƒ«ãƒ¼ãƒ—ã‚’ã‚¹ã‚­ãƒƒãƒ—
                                    let braceCount = 0;
                                    let tempIndex = lineIndex + 1;
                                    while (tempIndex < lines.length) {
                                        const tempLine = lines[tempIndex].trim();
                                        if (tempLine.includes('{')) braceCount++;
                                        if (tempLine.includes('}')) {
                                            braceCount--;
                                            if (braceCount <= 0) {
                                                lineIndex = tempIndex;
                                                break;
                                            }
                                        }
                                        tempIndex++;
                                    }
                                    // æ¡ä»¶ãŒå½ã®å ´åˆã¯ãƒ«ãƒ¼ãƒ—ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å‰Šé™¤
                                    const loopToRemove = loopStack.findIndex(loop => 
                                        loop.type === 'for' && loop.startLine === lineIndex
                                    );
                                    if (loopToRemove !== -1) {
                                        loopStack.splice(loopToRemove, 1);
                                    }
                                }
                            } else if (loopResult.type === 'while') {
                                // whileãƒ«ãƒ¼ãƒ—ã®å‡¦ç†
                                loopStack.push({
                                    type: 'while',
                                    startLine: lineIndex,
                                    condition: loopResult.condition,
                                    iterationCount: 0
                                });
                                
                                const conditionResult = analyzer.evaluateLoopCondition(loopResult.condition);
                                if (!conditionResult) {
                                    // æ¡ä»¶ãŒå½ã®å ´åˆã€ãƒ«ãƒ¼ãƒ—ã‚’ã‚¹ã‚­ãƒƒãƒ—
                                    let braceCount = 0;
                                    let tempIndex = lineIndex + 1;
                                    while (tempIndex < lines.length) {
                                        const tempLine = lines[tempIndex].trim();
                                        if (tempLine.includes('{')) braceCount++;
                                        if (tempLine.includes('}')) {
                                            braceCount--;
                                            if (braceCount <= 0) {
                                                lineIndex = tempIndex;
                                                break;
                                            }
                                        }
                                        tempIndex++;
                                    }
                                    loopStack.pop();
                                }
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // æ¡ä»¶åˆ†å²ã®å‡¦ç†ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
                        const conditionResult = analyzer.parseCondition(codeOnly);
                        if (conditionResult) {
                            if (conditionResult.type === 'if') {
                                // ifæ–‡ã®é–‹å§‹
                                const conditionInfo = {
                                    type: 'if-block',
                                    hasExecuted: conditionResult.result, // æ—¢ã«å®Ÿè¡Œã—ãŸãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚‹ã‹
                                    currentCondition: conditionResult.result
                                };
                                conditionStack.push(conditionInfo);
                                skipExecution = !conditionResult.result;
                                
                                // ãƒ‡ãƒãƒƒã‚°ç”¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
                                updateVariableOverlay(actualLineNumber, 'if', 
                                    `${conditionResult.condition} â†’ ${conditionResult.result ? 'å®Ÿè¡Œ' : 'ã‚¹ã‚­ãƒƒãƒ—'}`);
                                
                            } else if (conditionResult.type === 'elseif') {
                                if (conditionStack.length > 0 && conditionStack[conditionStack.length - 1].type === 'if-block') {
                                    const ifBlock = conditionStack[conditionStack.length - 1];
                                    
                                    // å‰ã®if/else ifãŒå®Ÿè¡Œã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ã€ã“ã®æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
                                    const shouldExecute = !ifBlock.hasExecuted && conditionResult.result;
                                    
                                    if (shouldExecute) {
                                        ifBlock.hasExecuted = true; // ã“ã®åˆ†å²ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’ãƒãƒ¼ã‚¯
                                    }
                                    
                                    skipExecution = !shouldExecute;
                                    
                                    // ãƒ‡ãƒãƒƒã‚°ç”¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
                                    updateVariableOverlay(actualLineNumber, 'else if', 
                                        `${conditionResult.condition} â†’ ${shouldExecute ? 'å®Ÿè¡Œ' : 'ã‚¹ã‚­ãƒƒãƒ—'}`);
                                }
                                
                            } else if (conditionResult.type === 'else') {
                                if (conditionStack.length > 0 && conditionStack[conditionStack.length - 1].type === 'if-block') {
                                    const ifBlock = conditionStack[conditionStack.length - 1];
                                    
                                    // å‰ã®if/else ifãŒå®Ÿè¡Œã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ã€elseã‚’å®Ÿè¡Œ
                                    const shouldExecute = !ifBlock.hasExecuted;
                                    
                                    if (shouldExecute) {
                                        ifBlock.hasExecuted = true;
                                    }
                                    
                                    skipExecution = !shouldExecute;
                                    
                                    // ãƒ‡ãƒãƒƒã‚°ç”¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
                                    updateVariableOverlay(actualLineNumber, 'else', 
                                        shouldExecute ? 'å®Ÿè¡Œ' : 'ã‚¹ã‚­ãƒƒãƒ—');
                                }
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // é–¢æ•°å®šç¾©ã®å‡¦ç†
                        const functionDeclaration = analyzer.parseFunctionDeclaration(codeOnly, actualLineNumber);
                        if (functionDeclaration) {
                            updateVariableOverlay(actualLineNumber, functionDeclaration.name, '[Function]');
                            lineIndex++;
                            continue;
                        }
                        
                        // é–¢æ•°å‘¼ã³å‡ºã—ã®å‡¦ç†
                        const functionCall = analyzer.parseFunctionCall(codeOnly, actualLineNumber);
                        if (functionCall) {
                            try {
                                if (functionCall.type === 'function_call') {
                                    const result = await analyzer.executeFunction(functionCall.name, functionCall.args, actualLineNumber);
                                    // é–¢æ•°å‘¼ã³å‡ºã—ã®çµæœã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è¡¨ç¤ºï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
                                } else if (functionCall.type === 'function_call_assignment') {
                                    const result = await analyzer.executeFunction(functionCall.funcName, functionCall.args, actualLineNumber);
                                    analyzer.setVariable(functionCall.varName, result, actualLineNumber, 'assignment', functionCall.varType);
                                    updateVariableOverlay(actualLineNumber, functionCall.varName, result);
                                } else if (functionCall.type === 'function_call_var_assignment') {
                                    const result = await analyzer.executeFunction(functionCall.funcName, functionCall.args, actualLineNumber);
                                    analyzer.setVariable(functionCall.varName, result, actualLineNumber, 'assignment');
                                    updateVariableOverlay(actualLineNumber, functionCall.varName, result);
                                }
                            } catch (e) {
                                addConsoleOutput(`é–¢æ•°å‘¼ã³å‡ºã—ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // returnæ–‡ã®å‡¦ç†
                        const returnResult = analyzer.parseReturn(codeOnly, actualLineNumber);
                        if (returnResult) {
                            updateVariableOverlay(actualLineNumber, 'return', returnResult.value);
                            addConsoleOutput(`return: ${returnResult.value}`);
                            // returnæ–‡ãŒå®Ÿè¡Œã•ã‚ŒãŸã‚‰é–¢æ•°ã‹ã‚‰æŠœã‘ã‚‹ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
                            lineIndex++;
                            continue;
                        }
                        
                        // switchæ–‡ã®å‡¦ç†
                        const switchResult = analyzer.parseSwitch(codeOnly);
                        if (switchResult) {
                            if (switchResult.type === 'switch') {
                                // switchå¼ã‚’è©•ä¾¡ã—ã¦ã‚¹ã‚¿ãƒƒã‚¯ã«ä¿å­˜
                                try {
                                    const switchValue = analyzer.safeEval(switchResult.expression);
                                    conditionStack.push({ 
                                        type: 'switch', 
                                        value: switchValue, 
                                        matched: false,
                                        executing: false,  // ç¾åœ¨å®Ÿè¡Œä¸­ã‹ã©ã†ã‹
                                        hasMatched: false  // ä¸€åº¦ã§ã‚‚ãƒãƒƒãƒã—ãŸã‹ã©ã†ã‹
                                    });
                                    updateVariableOverlay(actualLineNumber, 'switch', switchValue);
                                } catch (e) {
                                    addConsoleOutput(`switchå¼ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                                }
                            } else if (switchResult.type === 'case') {
                                if (conditionStack.length > 0 && conditionStack[conditionStack.length - 1].type === 'switch') {
                                    const switchInfo = conditionStack[conditionStack.length - 1];
                                    try {
                                        const caseValue = analyzer.safeEval(switchResult.value);
                                        
                                        // å€¤ãŒä¸€è‡´ã™ã‚‹ã‹ã€ã¾ãŸã¯æ—¢ã«fall-throughä¸­ã‹ã‚’ãƒã‚§ãƒƒã‚¯
                                        const isMatch = switchInfo.value === caseValue;
                                        
                                        if (isMatch && !switchInfo.hasMatched) {
                                            // æœ€åˆã®ãƒãƒƒãƒ
                                            switchInfo.matched = true;
                                            switchInfo.executing = true;
                                            switchInfo.hasMatched = true;
                                            skipExecution = false;
                                        } else if (switchInfo.executing) {
                                            // fall-throughä¸­
                                            switchInfo.matched = true;
                                            skipExecution = false;
                                        } else {
                                            // ãƒãƒƒãƒã—ãªã„ã€ã‹ã¤fall-throughä¸­ã§ã‚‚ãªã„
                                            switchInfo.matched = false;
                                            skipExecution = true;
                                        }
                                        
                                        updateVariableOverlay(actualLineNumber, 'case', `${caseValue} ${switchInfo.matched ? 'âœ“' : 'âœ—'}`);
                                    } catch (e) {
                                        addConsoleOutput(`caseè©•ä¾¡ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                                    }
                                }
                            } else if (switchResult.type === 'default') {
                                if (conditionStack.length > 0 && conditionStack[conditionStack.length - 1].type === 'switch') {
                                    const switchInfo = conditionStack[conditionStack.length - 1];
                                    
                                    // defaultç¯€ã¯ã€ã¾ã ãƒãƒƒãƒã—ã¦ã„ãªã„å ´åˆã¾ãŸã¯fall-throughä¸­ã®å ´åˆã«å®Ÿè¡Œ
                                    if (!switchInfo.hasMatched || switchInfo.executing) {
                                        switchInfo.executing = true;
                                        skipExecution = false;
                                        updateVariableOverlay(actualLineNumber, 'default', 'å®Ÿè¡Œ');
                                    } else {
                                        skipExecution = true;
                                        updateVariableOverlay(actualLineNumber, 'default', 'ã‚¹ã‚­ãƒƒãƒ—');
                                    }
                                }
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼æ–‡ã®å‡¦ç†
                        const controlFlow = analyzer.parseControlFlow(codeOnly);
                        if (controlFlow) {
                            if (controlFlow.type === 'break') {
                                // breakæ–‡ã®å‡¦ç†ã‚’æ”¹å–„
                                let breakHandled = false;
                                
                                // switchæ–‡å†…ã®breakã‚’ãƒã‚§ãƒƒã‚¯
                                if (conditionStack.length > 0 && conditionStack[conditionStack.length - 1].type === 'switch') {
                                    const switchInfo = conditionStack[conditionStack.length - 1];
                                    switchInfo.executing = false; // switchå®Ÿè¡Œã‚’åœæ­¢
                                    skipExecution = true; // å¾Œç¶šã®caseæ–‡ã‚’ã‚¹ã‚­ãƒƒãƒ—
                                    updateVariableOverlay(actualLineNumber, 'break', 'Switchçµ‚äº†');
                                    breakHandled = true;
                                }
                                // ãƒ«ãƒ¼ãƒ—å†…ã®breakã‚’ãƒã‚§ãƒƒã‚¯
                                else if (loopStack.length > 0) {
                                    updateVariableOverlay(actualLineNumber, 'break', 'ãƒ«ãƒ¼ãƒ—çµ‚äº†');
                                    // ãƒ«ãƒ¼ãƒ—ã‹ã‚‰æŠœã‘ã‚‹å‡¦ç†
                                    let braceCount = 0;
                                    let tempIndex = lineIndex + 1;
                                    while (tempIndex < lines.length) {
                                        const tempLine = lines[tempIndex].trim();
                                        if (tempLine.includes('{')) braceCount++;
                                        if (tempLine.includes('}')) {
                                            braceCount--;
                                            if (braceCount <= 0) {
                                                lineIndex = tempIndex;
                                                break;
                                            }
                                        }
                                        tempIndex++;
                                    }
                                    loopStack.pop(); // ãƒ«ãƒ¼ãƒ—ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ãƒãƒƒãƒ—
                                    breakHandled = true;
                                }
                                
                                if (!breakHandled) {
                                    updateVariableOverlay(actualLineNumber, 'break', 'ç„¡åŠ¹');
                                }
                            } else if (controlFlow.type === 'continue') {
                                updateVariableOverlay(actualLineNumber, 'continue', 'æ¬¡ã®åå¾©');
                                // continueå‡¦ç†ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
                                if (loopStack.length > 0) {
                                    const currentLoop = loopStack[loopStack.length - 1];
                                    lineIndex = currentLoop.startLine - 1; // ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹ã«æˆ»ã‚‹ï¼ˆ-1ã¯æ¬¡ã®incrementã§èª¿æ•´ï¼‰
                                }
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // ãƒ–ãƒ­ãƒƒã‚¯ã®çµ‚äº†
                        if (codeOnly === '}') {
                            // ãƒ«ãƒ¼ãƒ—ã®çµ‚äº†å‡¦ç†
                            if (loopStack.length > 0) {
                                const currentLoop = loopStack[loopStack.length - 1];
                                currentLoop.iterationCount++;
                                
                                // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢
                                if (currentLoop.iterationCount > MAX_LOOP_ITERATIONS) {
                                    addConsoleOutput('è­¦å‘Š: ãƒ«ãƒ¼ãƒ—ã®å®Ÿè¡Œå›æ•°ãŒä¸Šé™ã«é”ã—ã¾ã—ãŸ', 'warning');
                                    loopStack.pop();
                                    lineIndex++;
                                    continue;
                                }
                                
                                if (currentLoop.type === 'for') {
                                    // forãƒ«ãƒ¼ãƒ—ã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆå®Ÿè¡Œ
                                    const incrementResult = analyzer.executeForIncrement(currentLoop.increment, actualLineNumber);
                                    if (incrementResult) {
                                        // forãƒ«ãƒ¼ãƒ—ã®è¡Œã«ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆå¾Œã®å€¤ã‚’è¡¨ç¤ºï¼ˆãƒ«ãƒ¼ãƒ—ã‚«ã‚¦ãƒ³ã‚¿ã®é€²è¡Œã‚’å¯è¦–åŒ–ï¼‰
                                        const forLineNumber = currentLoop.startLine + 1; // startLineã¯0ãƒ™ãƒ¼ã‚¹ãªã®ã§+1
                                        updateVariableOverlay(forLineNumber, incrementResult.varName, incrementResult.value);
                                    }
                                }
                                
                                // ãƒ«ãƒ¼ãƒ—æ¡ä»¶ã®å†è©•ä¾¡
                                const conditionResult = analyzer.evaluateLoopCondition(currentLoop.condition);
                                
                                
                                if (conditionResult) {
                                    // æ¡ä»¶ãŒçœŸã®å ´åˆã€ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹ã«æˆ»ã‚‹
                                    lineIndex = currentLoop.startLine;
                                    continue;
                                } else {
                                    // æ¡ä»¶ãŒå½ã®å ´åˆã€ãƒ«ãƒ¼ãƒ—ã‚’çµ‚äº†
                                    loopStack.pop();
                                }
                            }
                            
                            // æ¡ä»¶åˆ†å²ã®çµ‚äº†å‡¦ç†
                            if (conditionStack.length > 0) {
                                const lastCondition = conditionStack[conditionStack.length - 1];
                                if (lastCondition && lastCondition.type === 'switch') {
                                    // switchæ–‡ã®çµ‚äº†
                                    conditionStack.pop();
                                } else if (lastCondition && lastCondition.type === 'if-block') {
                                    // if-else ifãƒ–ãƒ­ãƒƒã‚¯ã®çµ‚äº†
                                    conditionStack.pop();
                                } else {
                                    // é€šå¸¸ã®æ¡ä»¶åˆ†å²ã®çµ‚äº†
                                    conditionStack.pop();
                                }
                                skipExecution = false;
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // å®Ÿè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹å ´åˆ
                        if (skipExecution) {
                            lineIndex++;
                            continue;
                        }
                        
                        // å¤‰æ•°å®£è¨€ã®å‡¦ç†
                        const varDeclaration = analyzer.parseVariableDeclaration(codeOnly, actualLineNumber, lines, lineIndex);
                        if (varDeclaration) {
                            updateVariableOverlay(actualLineNumber, varDeclaration.varName, varDeclaration.value);
                            // è¤‡æ•°è¡Œã®å ´åˆã¯endLineã¾ã§ã‚¹ã‚­ãƒƒãƒ—
                            if (varDeclaration.endLine && varDeclaration.endLine > lineIndex) {
                                lineIndex = varDeclaration.endLine;
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // ä»£å…¥ã®å‡¦ç†
                        const assignment = analyzer.parseAssignment(codeOnly, actualLineNumber);
                        if (assignment) {
                            updateVariableOverlay(actualLineNumber, assignment.varName, assignment.value);
                            lineIndex++;
                            continue;
                        }
                        
                        // console.log ã®å‡¦ç†
                        const consoleResult = analyzer.parseConsoleLog(codeOnly);
                        if (consoleResult) {
                            addConsoleOutput(consoleResult);
                            lineIndex++;
                            continue;
                        }
                        
                        // ãã®ä»–ã®æ–‡ï¼ˆå‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼‰
                        lineIndex++;
                        
                    } catch (e) {
                        addConsoleOutput(`è¡Œ ${actualLineNumber} ã§ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'error');
                        lineIndex++;
                    }
                }
                
            } finally {
                console.log = originalConsoleLog;
            }
        }

        // ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½
        function resetExecution(full = true) {
            // ãƒ•ãƒ«ãƒªã‚»ãƒƒãƒˆæ™‚ã®ã¿å®Ÿè¡Œä¸­æ–­ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
            if (full) {
                executionAborted = true;
            }
            
            // å®Ÿè¡Œä¸­ã®å…¨ã¦ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ã‚¯ãƒªã‚¢
            currentTimeouts.forEach(timeoutId => {
                clearTimeout(timeoutId);
            });
            currentTimeouts.clear();
            
            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚‚ã‚¯ãƒªã‚¢
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
                scrollTimeout = null;
            }
            
            if (isProcessing && full) {
                isProcessing = false;
                stepWaiting = false;
                
                // å¾…æ©Ÿä¸­ã®Promiseã‚’è§£æ±º
                if (nextStepResolve) {
                    nextStepResolve();
                    nextStepResolve = null;
                }
                
                currentStep = 0;
                
                document.getElementById('executeBtn').disabled = false;
                document.getElementById('nextStepBtn').style.display = 'none';
                document.getElementById('stepInfo').style.display = 'none';
            }
            
            if (full) {
                variables = {};
                variableTracker.reset();
                errorManager.clear(); // ã‚¨ãƒ©ãƒ¼ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚‚ã‚¯ãƒªã‚¢
                clearConsole();
                displayCode(document.getElementById('codeInput').value);
                
                // ãƒ•ãƒ«ãƒªã‚»ãƒƒãƒˆæ™‚ã¯ä¸­æ–­ãƒ•ãƒ©ã‚°ã‚’å³åº§ã«ãƒªã‚»ãƒƒãƒˆ
                executionAborted = false;
            }
            
            resetCodeHighlight();
            resetVariableOverlays();
            updateExecutionModeUI();
        }

        // å®Ÿè¡Œçµæœãƒ‘ãƒãƒ«ã®ãƒˆã‚°ãƒ«æ©Ÿèƒ½
        function toggleOutputPanel() {
            const rightPanel = document.getElementById('rightPanel');
            const outputSection = rightPanel.querySelector('.output-section');
            const expandBtn = rightPanel.querySelector('.panel-expand-btn');
            const toggleBtn = rightPanel.querySelector('.panel-toggle-btn');
            
            if (rightPanel.classList.contains('collapsed')) {
                // ãƒ‘ãƒãƒ«ã‚’å±•é–‹
                rightPanel.classList.remove('collapsed');
                outputSection.style.display = 'block';
                expandBtn.style.display = 'none';
                toggleBtn.textContent = 'éè¡¨ç¤º';
            } else {
                // ãƒ‘ãƒãƒ«ã‚’æŠ˜ã‚ŠãŸãŸã¿
                rightPanel.classList.add('collapsed');
                outputSection.style.display = 'none';
                expandBtn.style.display = 'block';
                toggleBtn.textContent = 'è¡¨ç¤º';
            }
        }

        // å®Ÿè¡Œé–‹å§‹æ™‚ã«è‡ªå‹•ã§ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º
        function showOutputPanel() {
            const rightPanel = document.getElementById('rightPanel');
            const outputSection = rightPanel.querySelector('.output-section');
            const expandBtn = rightPanel.querySelector('.panel-expand-btn');
            const toggleBtn = rightPanel.querySelector('.panel-toggle-btn');
            
            rightPanel.classList.remove('collapsed');
            outputSection.style.display = 'block';
            expandBtn.style.display = 'none';
            toggleBtn.textContent = 'éè¡¨ç¤º';
        }

        // å®Ÿè¡Œçµæœãƒ‘ãƒãƒ«ã®è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
        function scrollOutputToBottom() {
            const outputConsole = document.getElementById('outputConsole');
            if (outputConsole) {
                outputConsole.scrollTop = outputConsole.scrollHeight;
            }
        }

        // ãƒ‘ãƒãƒ«ãƒªã‚µã‚¤ã‚ºæ©Ÿèƒ½
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        function initializeResize() {
            const resizeHandle = document.getElementById('resizeHandle');
            const rightPanel = document.getElementById('rightPanel');
            
            resizeHandle.addEventListener('mousedown', startResize);
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
        }

        function startResize(e) {
            isResizing = true;
            startX = e.clientX;
            const rightPanel = document.getElementById('rightPanel');
            startWidth = parseInt(window.getComputedStyle(rightPanel).getPropertyValue('flex-basis'), 10);
            
            // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚¹ã‚¿ã‚¤ãƒ«
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        }

        function doResize(e) {
            if (!isResizing) return;
            
            const diff = startX - e.clientX;
            const newWidth = startWidth + diff;
            const rightPanel = document.getElementById('rightPanel');
            
            // æœ€å°å¹…ã¨æœ€å¤§å¹…ã®åˆ¶é™
            const minWidth = 250;
            const maxWidth = 600;
            const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
            
            rightPanel.style.flexBasis = constrainedWidth + 'px';
        }

        function stopResize(e) {
            if (!isResizing) return;
            
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã®åˆæœŸåŒ–
        window.onload = function() {
            init();
            // å…±æœ‰ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’è‡ªå‹•èª­ã¿è¾¼ã¿
            loadSharedCodeIfAvailable();
        };

        // å…±æœ‰ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã®è‡ªå‹•èª­ã¿è¾¼ã¿æ©Ÿèƒ½
        function loadSharedCodeIfAvailable() {
            const sharedCode = window.getSharedCode && window.getSharedCode();
            
            if (sharedCode) {
                // ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã‚¨ãƒªã‚¢ã«è¨­å®š
                const codeInput = document.getElementById('codeInput');
                if (codeInput) {
                    codeInput.value = sharedCode;
                    displayCode(sharedCode);
                    
                    // é€šçŸ¥ã‚’è¡¨ç¤º
                    if (window.showNotification) {
                        window.showNotification('æ¡ç‚¹ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰ã‚³ãƒ¼ãƒ‰ãŒå…±æœ‰ã•ã‚Œã¾ã—ãŸï¼', 'success');
                    }
                    
                    // ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã€è‡ªå‹•çš„ã«å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰ã‚’å…¨è‡ªå‹•ã«è¨­å®š
                    const autoModeRadio = document.querySelector('input[name="executionMode"][value="auto"]');
                    if (autoModeRadio) {
                        autoModeRadio.checked = true;
                        onExecutionModeChange();
                    }
                }
            }
        }
    </script>
    
    <!-- å…±é€šãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ -->
    <script src="/assets/js/navigation.js"></script>
</body>
</html>
