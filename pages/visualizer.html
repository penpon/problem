<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript可視化ツール</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .main-content {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            align-items: flex-start;
        }

        .left-panel {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 20px;
        }

        .right-panel {
            flex: 0 0 350px;
            height: calc(100vh - 40px);
            position: sticky;
            top: 20px;
            min-width: 250px;
            max-width: 600px;
            align-self: flex-start;
        }

        .resize-handle {
            width: 8px;
            height: calc(100vh - 40px);
            background: #ddd;
            cursor: col-resize;
            position: sticky;
            top: 20px;
            border-left: 1px solid #ccc;
            border-right: 1px solid #ccc;
            transition: background 0.2s ease;
            align-self: flex-start;
        }

        .resize-handle:hover {
            background: #bbb;
        }

        .resize-handle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 30px;
            background: #888;
            border-radius: 2px;
        }

        .resize-handle:hover::before {
            color: #333;
        }

        .resize-handle:active {
            background: linear-gradient(to right, #ccc, #aaa, #ccc);
            border-color: #777;
        }

        .input-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-section {
            background: #f1f3f4;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #dadce0;
        }

        .code-section {
            background: #f8f8ff;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ddd6fe;
            max-height: 600px;
            overflow-y: auto;
            grid-column: 1 / -1;
        }

        .code-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .code-section-header h2 {
            margin: 0;
        }

        .output-section {
            background: #f0fdf4;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #bbf7d0;
            height: calc(100vh - 80px);
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .output-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #bbf7d0;
            padding-bottom: 10px;
        }

        .output-panel-header h2 {
            margin: 0;
            color: #059669;
        }

        .panel-toggle-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }

        .panel-toggle-btn:hover {
            background: #059669;
        }

        .right-panel.collapsed {
            flex: 0 0 40px;
        }

        .right-panel.collapsed .output-section {
            display: none;
        }

        .right-panel.collapsed + .resize-handle {
            display: none;
        }


        .panel-expand-btn {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%) rotate(-90deg);
            background: #10b981;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            writing-mode: vertical-lr;
        }

        .code-input {
            width: 100%;
            height: 400px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            background: #fff;
            resize: vertical;
        }

        .code-container {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            overflow-x: auto;
            position: relative;
        }

        .floating-auto-scroll-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            font-size: 14px;
            background: rgba(33, 150, 243, 0.9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 9999;
            transition: all 0.3s ease;
            opacity: 0.8;
            backdrop-filter: blur(6px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .floating-auto-scroll-btn:hover {
            opacity: 1;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }

        .floating-auto-scroll-btn.active {
            background: rgba(40, 167, 69, 0.8);
        }

        .floating-auto-scroll-btn.active:hover {
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        .code-line {
            padding: 2px 0;
            position: relative;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            min-height: 20px;
        }

        .code-line.highlight {
            background: #264f78;
            border-left: 4px solid #ffc107;
            padding-left: 8px;
            margin-left: -8px;
            transform: translateX(4px);
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.3);
        }

        .code-line.executing {
            background: #0e4429;
            border-left: 4px solid #28a745;
            padding-left: 8px;
            margin-left: -8px;
            animation: executeGlow 1s infinite;
        }

        @keyframes executeGlow {
            0% { box-shadow: 0 0 5px rgba(40, 167, 69, 0.5); }
            50% { box-shadow: 0 0 15px rgba(40, 167, 69, 0.8); }
            100% { box-shadow: 0 0 5px rgba(40, 167, 69, 0.5); }
        }

        .line-number {
            color: #858585;
            display: inline-block;
            width: 30px;
            text-align: right;
            margin-right: 15px;
            user-select: none;
        }

        .comment {
            color: #6a9955;
        }

        .keyword {
            color: #569cd6;
        }

        .string {
            color: #ce9178;
        }

        .function-name {
            color: #dcdcaa;
        }

        .variable {
            color: #9cdcfe;
        }

        .code-content {
            flex: 1;
            display: flex;
            align-items: center;
        }

        .variable-overlay {
            margin-left: 20px;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            background: rgba(40, 167, 69, 0.15);
            border: 1px solid rgba(40, 167, 69, 0.3);
            color: #28a745;
            opacity: 0;
            transition: all 0.5s ease;
            white-space: nowrap;
            max-width: 500px;
            min-width: 180px;
            overflow: visible;
            box-shadow: 0 2px 6px rgba(40, 167, 69, 0.2);
            position: relative;
        }
        
        .variable-overlay::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-right: 8px solid rgba(40, 167, 69, 0.3);
        }

        .variable-overlay.visible {
            opacity: 1;
        }

        .variable-overlay.changed {
            background: rgba(255, 193, 7, 0.3);
            border: 1px solid rgba(255, 193, 7, 0.6);
            color: #ffc107;
            animation: variableOverlayChange 1.5s ease;
        }
        
        .variable-overlay.function-type {
            background: rgba(156, 39, 176, 0.15);
            border: 1px solid rgba(156, 39, 176, 0.3);
            color: #9c27b0;
        }
        
        .variable-overlay.function-type::before {
            border-right-color: rgba(156, 39, 176, 0.3);
        }
        
        .variable-overlay.object-type {
            background: rgba(33, 150, 243, 0.15);
            border: 1px solid rgba(33, 150, 243, 0.3);
            color: #2196f3;
        }
        
        .variable-overlay.object-type::before {
            border-right-color: rgba(33, 150, 243, 0.3);
        }
        
        .variable-overlay.error-type {
            background: rgba(244, 67, 54, 0.15);
            border: 1px solid rgba(244, 67, 54, 0.3);
            color: #f44336;
        }
        
        .variable-overlay.error-type::before {
            border-right-color: rgba(244, 67, 54, 0.3);
        }

        @keyframes variableOverlayChange {
            0% {
                background: rgba(40, 167, 69, 0.5);
                transform: scale(1.05);
            }
            50% {
                background: rgba(255, 193, 7, 0.5);
                transform: scale(1.02);
            }
            100% {
                background: rgba(255, 193, 7, 0.3);
                transform: scale(1);
            }
        }

        .controls {
            text-align: center;
            margin: 30px 0;
        }

        .control-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .control-group label {
            font-weight: bold;
            color: #333;
            min-width: 120px;
            text-align: right;
        }

        select, button {
            padding: 10px 20px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button {
            background: linear-gradient(145deg, #2196f3, #1976d2);
            color: white;
            border: none;
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .reset-btn {
            background: linear-gradient(145deg, #ff9800, #f57c00);
        }

        .reset-btn:hover {
            box-shadow: 0 5px 15px rgba(255, 152, 0, 0.4);
        }

        .step-btn {
            background: linear-gradient(145deg, #673ab7, #5e35b1);
            color: white;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .step-btn:hover {
            box-shadow: 0 5px 15px rgba(103, 58, 183, 0.4);
            transform: translateY(-2px);
        }

        .step-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .step-info {
            background: #e8eaf6;
            border: 2px solid #673ab7;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .step-info h4 {
            margin: 0 0 10px 0;
            color: #673ab7;
            font-size: 1.1em;
        }

        .step-counter {
            font-size: 1.2em;
            font-weight: bold;
            color: #5e35b1;
        }

        .execution-mode {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .radio-label:hover {
            color: #2196f3;
        }

        .radio-label input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .speed-control {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .speed-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .speed-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: linear-gradient(145deg, #e3f2fd, #bbdefb);
            color: #1976d2;
            border: 2px solid #2196f3;
        }

        .speed-btn.active {
            background: linear-gradient(145deg, #2196f3, #1976d2);
            color: white;
        }

        .output-console {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .console-line {
            margin: 2px 0;
            word-break: break-all;
        }

        .error {
            color: #ff4444;
        }

        .warning {
            color: #ffaa00;
        }

        .sample-codes {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .sample-code-btn {
            background: linear-gradient(145deg, #4caf50, #45a049);
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .sample-code-btn:hover {
            background: linear-gradient(145deg, #45a049, #4caf50);
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto;
                gap: 15px;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .right-panel,
            .resize-handle {
                position: relative;
                top: auto;
                height: auto;
                min-height: 300px;
            }
            
            .output-section {
                height: auto;
                max-height: 400px;
            }
            
            .variable-overlay {
                margin-left: 10px;
                max-width: 250px;
                font-size: 11px;
            }
            
            .code-section {
                max-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 JavaScript可視化ツール</h1>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="input-section">
                    <h2>📝 コード入力</h2>
                    <textarea 
                        id="codeInput" 
                        class="code-input" 
                        placeholder="ここにJavaScriptコードを入力してください..."
                        oninput="displayCode(this.value)"
                    ></textarea>
                    
                    <div class="sample-codes">
                        <h4>サンプルコード：</h4>
                        <button class="sample-code-btn" onclick="loadSampleCode('variables')">変数操作</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('array')">配列操作</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('loop')">ループ処理</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('conditional')">条件分岐</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('functions')">関数定義</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('objects')">オブジェクト</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('switchCase')">Switch文</button>
                        <button class="sample-code-btn" onclick="loadSampleCode('arrayMethods')">配列操作2</button>
                    </div>
                </div>

                <div class="control-section">
                    <h2>⚙️ 実行制御</h2>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>実行モード:</label>
                            <div class="execution-mode">
                                <label class="radio-label">
                                    <input type="radio" name="executionMode" value="auto" checked onchange="onExecutionModeChange()">
                                    全自動実行
                                </label>
                                <label class="radio-label">
                                    <input type="radio" name="executionMode" value="step" onchange="onExecutionModeChange()">
                                    ステップ実行
                                </label>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <button id="executeBtn" onclick="startExecution()">🚀 実行開始</button>
                            <button id="nextStepBtn" class="step-btn" onclick="nextStep()" style="display: none;">▶️ 次のステップ</button>
                            <button class="reset-btn" onclick="resetExecution()">🔄 リセット</button>
                        </div>
                        
                        <div class="step-info" id="stepInfo" style="display: none;">
                            <h4>🔄 ステップ実行モード</h4>
                            <div class="step-counter">ステップ 0/0</div>
                            <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                                「次のステップ」ボタンをクリックして進んでください
                            </div>
                        </div>
                    </div>

                    <div class="speed-control">
                        <h3>⚡ 実行速度</h3>
                        <div class="speed-buttons">
                            <button class="speed-btn" onclick="setSpeed(0.25)">0.25x (ゆっくり)</button>
                            <button class="speed-btn active" onclick="setSpeed(0.5)">0.5x (標準)</button>
                            <button class="speed-btn" onclick="setSpeed(1)">1x (高速)</button>
                        </div>
                    </div>

                </div>

                <div class="code-section">
                    <div class="code-section-header">
                        <h2>💻 実行コード</h2>
                    </div>
                    <div class="code-container" id="codeContainer">
                        <!-- コードは JavaScript で生成 -->
                    </div>
                </div>
            </div>

            <div class="resize-handle" id="resizeHandle"></div>

            <div class="right-panel" id="rightPanel">
                <div class="output-section">
                    <div class="output-panel-header">
                        <h2>📄 実行結果</h2>
                        <button class="panel-toggle-btn" onclick="toggleOutputPanel()">非表示</button>
                    </div>
                    <div class="output-console" id="outputConsole">
                        <div class="console-line">コンソール出力がここに表示されます...</div>
                    </div>
                </div>
                <button class="panel-expand-btn" onclick="toggleOutputPanel()" style="display: none;">実行結果</button>
            </div>
        </div>
    </div>

    <script>
        // グローバル変数
        let animationSpeed = 0.5; // デフォルト速度
        let isProcessing = false;
        let currentStep = 0; // 現在のステップ番号
        let totalSteps = 0; // 総ステップ数
        let nextStepResolve = null; // 次のステップ待ちのPromise resolve
        let stepWaiting = false; // ステップ待機中フラグ
        let executionMode = 'auto'; // 実行モード: 'step' or 'auto'
        let codeLines = []; // 解析されたコード行
        let variables = {}; // 実行中の変数状態
        let consoleOutput = []; // コンソール出力
        let executionSteps = []; // 実行ステップ
        let currentScope = {}; // 現在のスコープ
        let scopeStack = []; // スコープスタック
        let loopCounters = {}; // ループカウンター
        let userScrolling = false; // ユーザーが手動スクロール中かどうか
        let scrollTimeout = null; // スクロールタイムアウト
        let autoScrollEnabled = true; // オートスクロール機能の有効/無効
        let executionAborted = false; // 実行中断フラグ
        let currentTimeouts = new Set(); // 現在のタイムアウトIDを追跡

        // サンプルコード
        const sampleCodes = {
            variables: `let name = "太郎";
let age = 25;
let isStudent = true;

console.log("名前: " + name);
console.log("年齢: " + age);

if (isStudent) {
    console.log("学生です");
} else {
    console.log("社会人です");
}

age = age + 1;
console.log("来年の年齢: " + age);`,

            array: `let numbers = [1, 2, 3, 4, 5];
let sum = 0;

console.log("配列: " + numbers);

for (let i = 0; i < numbers.length; i++) {
    sum = sum + numbers[i];
    console.log("i=" + i + ", sum=" + sum);
}

console.log("合計: " + sum);`,

            loop: `let count = 0;
let max = 5;

console.log("カウントアップ開始");

while (count < max) {
    count = count + 1;
    console.log("count: " + count);
}

console.log("カウント完了");`,

            conditional: `let score = 85;
let grade;

console.log("点数: " + score);

if (score >= 90) {
    grade = "A";
} else if (score >= 80) {
    grade = "B";
} else if (score >= 70) {
    grade = "C";
} else {
    grade = "D";
}

console.log("評価: " + grade);`,

            functions: `function add(a, b) {
    let result = a + b;
    console.log(a + " + " + b + " = " + result);
    return result;
}

function greet(name) {
    console.log("こんにちは、" + name + "さん！");
}

let x = 10;
let y = 20;
let sum = add(x, y);
greet("田中");
console.log("最終結果: " + sum);`,

            objects: `let person = {
    name: "山田太郎",
    age: 30,
    city: "東京"
};

console.log("名前: " + person.name);
console.log("年齢: " + person.age);
console.log("住所: " + person.city);

person.age = person.age + 1;
console.log("来年の年齢: " + person.age);`,

            switchCase: `let day = 3;
let dayName;

switch (day) {
    case 1:
        dayName = "月曜日";
        break;
    case 2:
        dayName = "火曜日";
        break;
    case 3:
        dayName = "水曜日";
        break;
    default:
        dayName = "不明";
        break;
}

console.log("今日は" + dayName + "です");`,

            arrayMethods: `let numbers = [1, 2, 3, 4, 5];
let doubled = [];

console.log("元の配列: " + numbers);

for (let i = 0; i < numbers.length; i++) {
    doubled[i] = numbers[i] * 2;
    console.log(numbers[i] + " × 2 = " + doubled[i]);
}

console.log("2倍した配列: " + doubled);`
        };

        // 初期化
        function init() {
            displayCode('');
            updateExecutionModeUI();
            clearConsole();
            loadSampleCode('variables'); // デフォルトサンプル
            detectUserScrolling(); // スクロール検出を有効化
            initializeResize(); // パネルリサイズ機能を初期化
        }

        // サンプルコードの読み込み
        function loadSampleCode(type) {
            if (sampleCodes[type]) {
                document.getElementById('codeInput').value = sampleCodes[type];
                displayCode(sampleCodes[type]);
                resetExecution();
            }
        }

        // コード表示関数
        function displayCode(code) {
            const container = document.getElementById('codeContainer');
            
            // オートスクロールボタンの状態を保存
            const existingBtn = document.getElementById('autoScrollBtn');
            let buttonActive = true;
            if (existingBtn) {
                buttonActive = existingBtn.classList.contains('active');
                existingBtn.remove(); // 既存のボタンを削除
            }
            
            if (!code.trim()) {
                container.innerHTML = '<div class="console-line">コードを入力してください...</div>';
                // ボタンをbody要素に追加（ビューポート固定）
                const buttonHtml = `<button id="autoScrollBtn" class="floating-auto-scroll-btn ${buttonActive ? 'active' : ''}" onclick="toggleAutoScroll()">${buttonActive ? '📍 ON' : '🚫 OFF'}</button>`;
                document.body.insertAdjacentHTML('beforeend', buttonHtml);
                return;
            }
            
            codeLines = code.split('\n');
            
            const codeHtml = codeLines.map((line, index) => {
                const lineNumber = index + 1;
                
                // 元のコードをそのまま表示（HTMLエスケープのみ）
                let displayLine = line
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#x27;');
                
                return `<div class="code-line" id="code-line-${lineNumber}">
                    <div class="code-content">
                        <span class="line-number">${lineNumber}</span>${displayLine}
                    </div>
                    <div class="variable-overlay" id="overlay-line-${lineNumber}"></div>
                </div>`;
            }).join('');
            
            // コードのみを設定
            container.innerHTML = codeHtml;
            
            // ボタンをbody要素に追加（ビューポート固定）
            const buttonHtml = `<button id="autoScrollBtn" class="floating-auto-scroll-btn ${buttonActive ? 'active' : ''}" onclick="toggleAutoScroll()">${buttonActive ? '📍 ON' : '🚫 OFF'}</button>`;
            document.body.insertAdjacentHTML('beforeend', buttonHtml);
        }

        // ユーザーのスクロール操作を検出
        function detectUserScrolling() {
            const codeSection = document.querySelector('.code-section');
            if (codeSection) {
                codeSection.addEventListener('scroll', () => {
                    userScrolling = true;
                    if (scrollTimeout) {
                        clearTimeout(scrollTimeout);
                        currentTimeouts.delete(scrollTimeout);
                    }
                    // 3秒後にスクロール状態をリセット
                    scrollTimeout = setTimeout(() => {
                        currentTimeouts.delete(scrollTimeout);
                        userScrolling = false;
                    }, 3000);
                    currentTimeouts.add(scrollTimeout);
                });
            }
        }

        // オートスクロール切り替え機能
        function toggleAutoScroll() {
            autoScrollEnabled = !autoScrollEnabled;
            const btn = document.getElementById('autoScrollBtn');
            if (autoScrollEnabled) {
                btn.textContent = '📍 ON';
                btn.classList.add('active');
            } else {
                btn.textContent = '🚫 OFF';
                btn.classList.remove('active');
            }
        }

        // コードハイライト関数
        function highlightCodeLine(lineNumber, duration = 1000) {
            // リセット
            document.querySelectorAll('.code-line').forEach(line => {
                line.classList.remove('highlight', 'executing');
            });
            
            // 指定行をハイライト
            const codeLine = document.getElementById(`code-line-${lineNumber}`);
            if (codeLine) {
                codeLine.classList.add('executing');
                
                // オートスクロールが有効かつユーザーがスクロール中でない場合のみ自動スクロール
                if (autoScrollEnabled && !userScrolling) {
                    setTimeout(() => {
                        codeLine.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center' 
                        });
                    }, 100);
                }
                
                // 指定時間後にハイライトを完了に変更
                const timeoutId = setTimeout(() => {
                    currentTimeouts.delete(timeoutId);
                    codeLine.classList.remove('executing');
                    codeLine.classList.add('highlight');
                }, duration / animationSpeed);
                
                // タイムアウトIDを追跡
                currentTimeouts.add(timeoutId);
            }
        }

        // コードハイライトのリセット
        function resetCodeHighlight() {
            document.querySelectorAll('.code-line').forEach(line => {
                line.classList.remove('highlight', 'executing');
            });
        }

        // 高度な変数追跡機能
        class VariableTracker {
            constructor() {
                this.variables = {};
                this.variableHistory = new Map(); // 変数の変更履歴
                this.lineToVariables = new Map(); // 行番号から変数へのマッピング
            }

            // 変数を設定
            setVariable(name, value, lineNumber, changeType = 'assignment') {
                const previousValue = this.variables[name];
                this.variables[name] = value;
                
                // 履歴を記録
                if (!this.variableHistory.has(name)) {
                    this.variableHistory.set(name, []);
                }
                this.variableHistory.get(name).push({
                    value: value,
                    lineNumber: lineNumber,
                    changeType: changeType,
                    timestamp: Date.now()
                });
                
                // 行と変数の関連付け
                if (!this.lineToVariables.has(lineNumber)) {
                    this.lineToVariables.set(lineNumber, []);
                }
                this.lineToVariables.get(lineNumber).push({
                    name: name,
                    value: value,
                    previousValue: previousValue,
                    changeType: changeType
                });
                
                return { previousValue, newValue: value };
            }

            // 変数を取得
            getVariable(name) {
                return this.variables[name];
            }

            // すべての変数を取得
            getAllVariables() {
                return { ...this.variables };
            }

            // 指定行の変数変更を取得
            getLineVariables(lineNumber) {
                return this.lineToVariables.get(lineNumber) || [];
            }

            // 変数の履歴を取得
            getVariableHistory(name) {
                return this.variableHistory.get(name) || [];
            }

            // リセット
            reset() {
                this.variables = {};
                this.variableHistory.clear();
                this.lineToVariables.clear();
            }
        }

        // グローバル変数追跡インスタンス
        let variableTracker = new VariableTracker();
        
        // コメント状態管理
        let isInMultiLineComment = false;
        
        // コメント判定関数
        function isCommentLine(line) {
            const trimmedLine = line.trim();
            
            // 空行
            if (!trimmedLine) {
                return true;
            }
            
            // 1行コメント（//で始まる）
            if (trimmedLine.startsWith('//')) {
                return true;
            }
            
            // 複数行コメントの開始をチェック
            if (trimmedLine.includes('/*')) {
                isInMultiLineComment = true;
            }
            
            // 複数行コメント中
            if (isInMultiLineComment) {
                // 複数行コメントの終了をチェック
                if (trimmedLine.includes('*/')) {
                    isInMultiLineComment = false;
                    // */より後にコードがある場合は、コメント行ではない
                    const afterComment = trimmedLine.substring(trimmedLine.indexOf('*/') + 2).trim();
                    return afterComment === '';
                }
                return true;
            }
            
            // 行内にコメントがある場合、コメント部分を除いて判定
            const commentIndex = trimmedLine.indexOf('//');
            if (commentIndex !== -1) {
                const beforeComment = trimmedLine.substring(0, commentIndex).trim();
                return beforeComment === '';
            }
            
            return false;
        }
        
        // コメント除去関数（コード部分のみを抽出）
        function removeComments(line) {
            const trimmedLine = line.trim();
            
            // 複数行コメント中の場合
            if (isInMultiLineComment) {
                if (trimmedLine.includes('*/')) {
                    isInMultiLineComment = false;
                    return trimmedLine.substring(trimmedLine.indexOf('*/') + 2).trim();
                }
                return '';
            }
            
            // 行内コメントの処理
            let result = trimmedLine;
            
            // 文字列リテラル内のコメント記号を保護
            const stringMatches = [];
            result = result.replace(/"([^"]*)"/g, (match) => {
                stringMatches.push(match);
                return `__STRING_${stringMatches.length - 1}__`;
            });
            result = result.replace(/'([^']*)'/g, (match) => {
                stringMatches.push(match);
                return `__STRING_${stringMatches.length - 1}__`;
            });
            
            // コメント部分を削除
            const commentIndex = result.indexOf('//');
            if (commentIndex !== -1) {
                result = result.substring(0, commentIndex).trim();
            }
            
            const multiCommentStart = result.indexOf('/*');
            if (multiCommentStart !== -1) {
                const multiCommentEnd = result.indexOf('*/', multiCommentStart);
                if (multiCommentEnd !== -1) {
                    result = result.substring(0, multiCommentStart) + result.substring(multiCommentEnd + 2);
                } else {
                    result = result.substring(0, multiCommentStart);
                    isInMultiLineComment = true;
                }
                result = result.trim();
            }
            
            // 文字列リテラルを復元
            stringMatches.forEach((str, index) => {
                result = result.replace(`__STRING_${index}__`, str);
            });
            
            return result;
        }

        // 変数オーバーレイの更新（改良版）
        function updateVariableOverlay(lineNumber, variableName, value, changeType = 'assignment') {
            try {
                const overlay = document.getElementById(`overlay-line-${lineNumber}`);
                if (!overlay) return;
                
                // 値の型を判定
                const valueType = getValueType(value);
                const typeIcon = getTypeIcon(valueType);
                const formattedValue = formatValueForDisplay(value, valueType);
            
            // 既存のオーバーレイ内容を取得
            const existingVars = overlay.textContent ? 
                overlay.textContent.split(' | ').filter(s => s.trim()) : [];
            
            // 新しい変数情報を作成（型アイコン付き）
            const newVarDisplay = `${typeIcon} ${variableName}: ${formattedValue}`;
            
            // 既存の同名変数を更新、または新規追加
            let found = false;
            const updatedVars = existingVars.map(varDisplay => {
                if (varDisplay.includes(`${variableName}:`)) {
                    found = true;
                    return newVarDisplay;
                }
                return varDisplay;
            });
            
            if (!found) {
                updatedVars.push(newVarDisplay);
            }
            
            // オーバーレイを更新
            const newDisplay = updatedVars.join(' | ');
            const previousValue = overlay.textContent;
            
            if (previousValue !== newDisplay) {
                overlay.textContent = newDisplay;
                overlay.classList.add('visible');
                
                // 型に応じたクラスを追加
                overlay.classList.remove('function-type', 'object-type', 'error-type');
                if (valueType === 'function') {
                    overlay.classList.add('function-type');
                } else if (valueType === 'object') {
                    overlay.classList.add('object-type');
                } else if (changeType === 'error') {
                    overlay.classList.add('error-type');
                }
                
                if (previousValue && previousValue !== '') {
                    // 値が変化した場合のアニメーション
                    overlay.classList.remove('changed');
                    
                    const timeoutId1 = setTimeout(() => {
                        currentTimeouts.delete(timeoutId1);
                        overlay.classList.add('changed');
                    }, 10);
                    currentTimeouts.add(timeoutId1);
                    
                    const timeoutId2 = setTimeout(() => {
                        currentTimeouts.delete(timeoutId2);
                        overlay.classList.remove('changed');
                    }, 1500);
                    currentTimeouts.add(timeoutId2);
                }
            }
            } catch (e) {
                console.warn(`変数オーバーレイ表示エラー (行 ${lineNumber}):`, e.message);
                // エラー時でも基本的な表示は試行
                try {
                    const overlay = document.getElementById(`overlay-line-${lineNumber}`);
                    if (overlay) {
                        overlay.textContent = `${variableName}: [エラー]`;
                        overlay.classList.add('visible', 'error-type');
                    }
                } catch (fallbackError) {
                    // フォールバックも失敗した場合は無視
                }
            }
        }
        
        // 値の型を判定
        function getValueType(value) {
            if (value === null) return 'null';
            if (value === undefined) return 'undefined';
            if (typeof value === 'function') return 'function';
            if (Array.isArray(value)) return 'array';
            if (typeof value === 'object') return 'object';
            if (typeof value === 'string') return 'string';
            if (typeof value === 'number') return 'number';
            if (typeof value === 'boolean') return 'boolean';
            return 'unknown';
        }
        
        // 型に応じたアイコンを取得
        function getTypeIcon(type) {
            const icons = {
                'string': '📝',
                'number': '🔢',
                'boolean': '✅',
                'array': '📋',
                'object': '📦',
                'function': '⚙️',
                'null': '🚫',
                'undefined': '❓',
                'unknown': '❔'
            };
            return icons[type] || '❔';
        }
        
        // 表示用の値フォーマット
        function formatValueForDisplay(value, type) {
            if (value === null) return 'null';
            if (value === undefined) return 'undefined';
            
            switch (type) {
                case 'string':
                    return `"${value.length > 30 ? value.substring(0, 30) + '...' : value}"`;
                case 'array':
                    // 配列の要素を実際に表示（長さ制限付き）
                    if (value.length <= 10) {
                        return `[${value.join(', ')}]`;
                    } else {
                        return `[${value.slice(0, 5).join(', ')}, ...${value.length}個]`;
                    }
                case 'object':
                    const keys = Object.keys(value);
                    return `{${keys.length}個のプロパティ}`;
                case 'function':
                    return value.name ? `${value.name}()` : 'function()';
                case 'number':
                    return value.toString();
                case 'boolean':
                    return value ? 'true' : 'false';
                default:
                    return JSON.stringify(value);
            }
        }

        // 複数変数を同時に更新
        function updateMultipleVariableOverlays(lineNumber, variables) {
            const overlay = document.getElementById(`overlay-line-${lineNumber}`);
            if (!overlay) return;
            
            const varDisplays = variables.map(v => 
                `${v.name}: ${JSON.stringify(v.value)}`
            );
            
            const newDisplay = varDisplays.join(' | ');
            const previousValue = overlay.textContent;
            
            if (previousValue !== newDisplay) {
                overlay.textContent = newDisplay;
                overlay.classList.add('visible');
                
                if (previousValue && previousValue !== '') {
                    overlay.classList.remove('changed');
                    
                    const timeoutId1 = setTimeout(() => {
                        currentTimeouts.delete(timeoutId1);
                        overlay.classList.add('changed');
                    }, 10);
                    currentTimeouts.add(timeoutId1);
                    
                    const timeoutId2 = setTimeout(() => {
                        currentTimeouts.delete(timeoutId2);
                        overlay.classList.remove('changed');
                    }, 1500);
                    currentTimeouts.add(timeoutId2);
                }
            }
        }

        // 変数オーバーレイのリセット
        function resetVariableOverlays() {
            document.querySelectorAll('.variable-overlay').forEach(overlay => {
                overlay.textContent = '';
                overlay.classList.remove('visible', 'changed');
            });
        }

        // エラー管理システム
        class ErrorManager {
            constructor() {
                this.errors = [];
                this.warnings = [];
                this.debugInfo = [];
            }
            
            logError(message, lineNumber, context = {}) {
                const error = {
                    type: 'error',
                    message: message,
                    lineNumber: lineNumber,
                    timestamp: new Date().toISOString(),
                    context: context
                };
                this.errors.push(error);
                this.displayError(error);
                return error;
            }
            
            logWarning(message, lineNumber, context = {}) {
                const warning = {
                    type: 'warning',
                    message: message,
                    lineNumber: lineNumber,
                    timestamp: new Date().toISOString(),
                    context: context
                };
                this.warnings.push(warning);
                this.displayWarning(warning);
                return warning;
            }
            
            logDebug(message, lineNumber, data = {}) {
                const debug = {
                    type: 'debug',
                    message: message,
                    lineNumber: lineNumber,
                    timestamp: new Date().toISOString(),
                    data: data
                };
                this.debugInfo.push(debug);
                // デバッグ情報は通常表示しない（開発者モード時のみ）
                return debug;
            }
            
            displayError(error) {
                const errorMsg = `🚫 行${error.lineNumber}: ${error.message}`;
                if (error.context && Object.keys(error.context).length > 0) {
                    const contextMsg = `   詳細: ${JSON.stringify(error.context, null, 2)}`;
                    addConsoleOutput(errorMsg, 'error');
                    addConsoleOutput(contextMsg, 'error');
                } else {
                    addConsoleOutput(errorMsg, 'error');
                }
            }
            
            displayWarning(warning) {
                const warningMsg = `⚠️ 行${warning.lineNumber}: ${warning.message}`;
                addConsoleOutput(warningMsg, 'warning');
            }
            
            clear() {
                this.errors = [];
                this.warnings = [];
                this.debugInfo = [];
            }
            
            getErrorSummary() {
                return {
                    errorCount: this.errors.length,
                    warningCount: this.warnings.length,
                    debugCount: this.debugInfo.length,
                    lastError: this.errors.length > 0 ? this.errors[this.errors.length - 1] : null
                };
            }
        }
        
        // グローバルエラーマネージャ
        let errorManager = new ErrorManager();

        // コンソール出力
        function addConsoleOutput(message, type = 'normal') {
            const console = document.getElementById('outputConsole');
            const line = document.createElement('div');
            line.className = `console-line ${type}`;
            line.textContent = message;
            console.appendChild(line);
            scrollOutputToBottom();
        }

        // コンソールクリア
        function clearConsole(showPlaceholder = true) {
            const console = document.getElementById('outputConsole');
            if (showPlaceholder) {
                console.innerHTML = '<div class="console-line">コンソール出力がここに表示されます...</div>';
            } else {
                console.innerHTML = '';
            }
        }

        // 速度設定
        function setSpeed(speed) {
            animationSpeed = speed;
            document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        // 実行モード変更
        function onExecutionModeChange() {
            const selectedMode = document.querySelector('input[name="executionMode"]:checked').value;
            executionMode = selectedMode;
            updateExecutionModeUI();
        }

        // 実行モードに応じたUI表示更新
        function updateExecutionModeUI() {
            const stepInfo = document.getElementById('stepInfo');
            const nextStepBtn = document.getElementById('nextStepBtn');
            
            if (executionMode === 'step') {
                if (isProcessing) {
                    stepInfo.style.display = 'block';
                    nextStepBtn.style.display = 'inline-block';
                }
            } else {
                stepInfo.style.display = 'none';
                nextStepBtn.style.display = 'none';
            }
        }

        // ステップ実行：次のステップまで待機
        function waitForNextStep() {
            return new Promise((resolve, reject) => {
                // 実行が中断された場合は即座にリジェクト
                if (executionAborted) {
                    reject(new Error('実行が中断されました'));
                    return;
                }
                
                if (!stepWaiting) {
                    resolve();
                    return;
                }
                
                nextStepResolve = resolve;
                updateStepButton();
            });
        }

        // 通常のタイマー（アニメーション用）
        function animationDelay(duration) {
            return new Promise((resolve, reject) => {
                // 実行が中断された場合は即座にリジェクト
                if (executionAborted) {
                    reject(new Error('実行が中断されました'));
                    return;
                }
                
                const timeoutId = setTimeout(() => {
                    currentTimeouts.delete(timeoutId);
                    
                    // タイムアウト実行時にも中断フラグをチェック
                    if (executionAborted) {
                        reject(new Error('実行が中断されました'));
                    } else {
                        resolve();
                    }
                }, duration / animationSpeed);
                
                // タイムアウトIDを追跡
                currentTimeouts.add(timeoutId);
            });
        }

        // 次のステップに進む
        function nextStep() {
            if (nextStepResolve) {
                const resolveFunc = nextStepResolve;
                nextStepResolve = null;
                currentStep++;
                updateStepDisplay();
                resolveFunc();
            }
        }

        // ステップボタンの表示更新
        function updateStepButton() {
            const stepBtn = document.getElementById('nextStepBtn');
            if (stepBtn && stepWaiting) {
                stepBtn.disabled = false;
                if (currentStep < totalSteps - 1) {
                    stepBtn.textContent = `▶️ 次のステップ (${currentStep + 1}/${totalSteps})`;
                } else {
                    stepBtn.textContent = '🏁 実行完了';
                }
            }
        }

        // ステップ表示の更新
        function updateStepDisplay() {
            const stepCounter = document.querySelector('.step-counter');
            if (stepCounter) {
                stepCounter.textContent = `ステップ ${currentStep}/${totalSteps}`;
            }
        }

        // 実行処理のメイン関数
        async function startExecution() {
            if (isProcessing) {
                return;
            }
            
            const code = document.getElementById('codeInput').value.trim();
            if (!code) {
                addConsoleOutput('エラー: コードが入力されていません', 'error');
                return;
            }
            
            // 実行フラグを初期化（即座にリセット）
            executionAborted = false;
            
            // 実行結果パネルを表示
            showOutputPanel();
            
            // 既存のタイムアウトをクリア
            currentTimeouts.forEach(timeoutId => {
                clearTimeout(timeoutId);
            });
            currentTimeouts.clear();
            
            isProcessing = true;
            currentStep = 0;
            nextStepResolve = null;
            
            // 実行モードに応じて処理を分岐
            if (executionMode === 'step') {
                stepWaiting = true;
            } else {
                stepWaiting = false;
            }
            
            document.getElementById('executeBtn').disabled = true;
            
            // 実行モードに応じてUI表示を設定
            if (executionMode === 'step') {
                document.getElementById('nextStepBtn').style.display = 'inline-block';
                document.getElementById('stepInfo').style.display = 'block';
                updateStepDisplay();
                updateStepButton();
            } else {
                document.getElementById('nextStepBtn').style.display = 'none';
                document.getElementById('stepInfo').style.display = 'none';
            }
            
            resetExecution(false);
            clearConsole(false); // 実行開始時にコンソールを完全にクリア
            
            try {
                totalSteps = codeLines.length;
                await executeCodeStepByStep(code);
                
                // 正常終了の場合
                if (!executionAborted) {
                    addConsoleOutput('実行完了', 'normal');
                }
                
            } catch (error) {
                // 中断エラーは特別に処理
                if (error.message === '実行が中断されました') {
                    addConsoleOutput('実行が中断されました', 'warning');
                } else {
                    addConsoleOutput('実行エラー: ' + error.message, 'error');
                }
            } finally {
                // 実行終了時のクリーンアップ
                isProcessing = false;
                stepWaiting = false;
                nextStepResolve = null;
                currentStep = 0;
                
                document.getElementById('executeBtn').disabled = false;
                document.getElementById('nextStepBtn').style.display = 'none';
                document.getElementById('stepInfo').style.display = 'none';
                
                // 全てのタイムアウトをクリア
                currentTimeouts.forEach(timeoutId => {
                    clearTimeout(timeoutId);
                });
                currentTimeouts.clear();
            }
        }

        // 高度なコード解析機能
        class CodeAnalyzer {
            constructor(variableTracker, globalVariables) {
                this.variableTracker = variableTracker;
                this.variables = {};
                this.globalVariables = globalVariables;
                this.lineToVarMap = new Map();
                this.loopStack = [];
                this.loopCounters = new Map();
                this.functions = new Map(); // 関数定義を保存
                this.scopeStack = []; // スコープスタック
                this.callStack = []; // 関数呼び出しスタック
                this.currentScope = { variables: {}, parent: null, type: 'global' };
                this.breakFlag = false; // break文フラグ
                this.continueFlag = false; // continue文フラグ
                this.returnFlag = false; // return文フラグ
                this.returnValue = undefined; // return値
            }
            
            // スコープ管理メソッド
            pushScope(type = 'block', name = null) {
                const newScope = {
                    variables: {},
                    parent: this.currentScope,
                    type: type,
                    name: name
                };
                this.scopeStack.push(this.currentScope);
                this.currentScope = newScope;
                return newScope;
            }
            
            popScope() {
                if (this.scopeStack.length > 0) {
                    this.currentScope = this.scopeStack.pop();
                }
            }
            
            // 変数を設定（スコープを考慮）
            setVariable(name, value, lineNumber, changeType = 'assignment', declType = null) {
                let targetScope = this.currentScope;
                
                // 宣言の場合は現在のスコープに追加
                if (declType === 'let' || declType === 'const' || declType === 'var') {
                    // varの場合は関数スコープまたはグローバルスコープに追加
                    if (declType === 'var') {
                        while (targetScope.parent && targetScope.type !== 'function' && targetScope.type !== 'global') {
                            targetScope = targetScope.parent;
                        }
                    }
                    targetScope.variables[name] = { value, type: declType, constant: declType === 'const' };
                } else {
                    // 代入の場合は、変数が存在するスコープを探す
                    let searchScope = this.currentScope;
                    let found = false;
                    while (searchScope) {
                        if (searchScope.variables[name]) {
                            // const変数への再代入チェック
                            if (searchScope.variables[name].constant) {
                                throw new Error(`定数 ${name} に再代入はできません`);
                            }
                            searchScope.variables[name].value = value;
                            found = true;
                            break;
                        }
                        searchScope = searchScope.parent;
                    }
                    
                    // 変数が見つからない場合はグローバルスコープに追加（varの動作）
                    if (!found) {
                        let globalScope = this.currentScope;
                        while (globalScope.parent) {
                            globalScope = globalScope.parent;
                        }
                        globalScope.variables[name] = { value, type: 'var', constant: false };
                    }
                }
                
                // 従来のシステムとの互換性のため
                this.variables[name] = value;
                this.globalVariables[name] = value;
                this.variableTracker.setVariable(name, value, lineNumber, changeType);
                
                return { varName: name, value, type: changeType };
            }
            
            // 変数を取得（スコープチェーンを検索）
            getVariable(name) {
                let searchScope = this.currentScope;
                while (searchScope) {
                    if (searchScope.variables[name]) {
                        return searchScope.variables[name].value;
                    }
                    searchScope = searchScope.parent;
                }
                // 従来のシステムからも検索
                return this.variables[name];
            }
            
            // 変数同期（グローバル変数からローカル変数を更新）
            syncFromGlobal() {
                for (const [name, value] of Object.entries(this.globalVariables)) {
                    this.variables[name] = value;
                }
            }
            
            // 変数同期（ローカル変数からグローバル変数を更新）
            syncToGlobal() {
                for (const [name, value] of Object.entries(this.variables)) {
                    this.globalVariables[name] = value;
                }
            }

            // 改良された安全な式評価（evalを使わない）
            safeEval(expression, context = null) {
                try {
                    const ctx = context || this.getAllVariablesFromScope();
                    return this.evaluateExpression(expression.trim(), ctx);
                } catch (e) {
                    throw new Error(`式の評価エラー: ${e.message}`);
                }
            }
            
            // すべてのスコープから変数を収集
            getAllVariablesFromScope() {
                const allVars = {};
                let searchScope = this.currentScope;
                while (searchScope) {
                    for (const [name, varInfo] of Object.entries(searchScope.variables)) {
                        if (!(name in allVars)) {
                            allVars[name] = varInfo.value;
                        }
                    }
                    searchScope = searchScope.parent;
                }
                // 従来システムの変数も追加
                for (const [name, value] of Object.entries(this.variables)) {
                    if (!(name in allVars)) {
                        allVars[name] = value;
                    }
                }
                return allVars;
            }
            
            // 式を評価（再帰的に処理）
            evaluateExpression(expr, context) {
                expr = expr.trim();
                
                // 末尾のセミコロンを除去
                if (expr.endsWith(';')) {
                    expr = expr.slice(0, -1).trim();
                }
                
                // リテラル値
                if (expr === 'true') return true;
                if (expr === 'false') return false;
                if (expr === 'null') return null;
                if (expr === 'undefined') return undefined;
                
                // 数値リテラル（セミコロン除去後）
                if (/^-?\d+(\.\d+)?$/.test(expr)) {
                    return parseFloat(expr);
                }
                
                // 文字列リテラル
                if ((expr.startsWith('"') && expr.endsWith('"')) || 
                    (expr.startsWith("'") && expr.endsWith("'"))) {
                    return expr.slice(1, -1);
                }
                
                // 配列リテラル
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const arrayContent = expr.slice(1, -1).trim();
                    if (!arrayContent) return [];
                    
                    const elements = this.parseCommaSeparated(arrayContent);
                    return elements.map(el => this.evaluateExpression(el, context));
                }
                
                // オブジェクトリテラル（基本的な対応）
                if (expr.startsWith('{') && expr.endsWith('}')) {
                    const objContent = expr.slice(1, -1).trim();
                    if (!objContent) return {};
                    
                    const obj = {};
                    const properties = this.parseCommaSeparated(objContent);
                    for (const prop of properties) {
                        const colonIndex = prop.indexOf(':');
                        if (colonIndex !== -1) {
                            const key = prop.substring(0, colonIndex).trim();
                            const value = prop.substring(colonIndex + 1).trim();
                            const cleanKey = key.replace(/["']/g, '');
                            obj[cleanKey] = this.evaluateExpression(value, context);
                        }
                    }
                    return obj;
                }
                
                // 変数参照
                if (/^\w+$/.test(expr)) {
                    if (expr in context) {
                        return context[expr];
                    }
                    throw new Error(`未定義の変数: ${expr}`);
                }
                
                // プロパティアクセス（ドット記法）
                if (expr.includes('.')) {
                    const parts = expr.split('.');
                    let result = context[parts[0]];
                    if (result === undefined) {
                        throw new Error(`未定義の変数: ${parts[0]}`);
                    }
                    
                    for (let i = 1; i < parts.length; i++) {
                        if (result && typeof result === 'object') {
                            result = result[parts[i]];
                        } else {
                            throw new Error(`プロパティにアクセスできません: ${parts[i]}`);
                        }
                    }
                    return result;
                }
                
                // 配列アクセス
                if (expr.includes('[') && expr.includes(']')) {
                    const bracketIndex = expr.indexOf('[');
                    const varName = expr.substring(0, bracketIndex);
                    const indexExpr = expr.substring(bracketIndex + 1, expr.lastIndexOf(']'));
                    
                    const arrayValue = context[varName];
                    const index = this.evaluateExpression(indexExpr, context);
                    
                    if (Array.isArray(arrayValue) || typeof arrayValue === 'object') {
                        return arrayValue[index];
                    }
                    throw new Error(`配列またはオブジェクトではありません: ${varName}`);
                }
                
                // 算術演算子の処理
                return this.evaluateArithmeticExpression(expr, context);
            }
            
            // 算術式の評価
            evaluateArithmeticExpression(expr, context) {
                // 括弧の処理
                while (expr.includes('(')) {
                    const innerExpr = this.extractParentheses(expr);
                    const result = this.evaluateExpression(innerExpr.content, context);
                    expr = expr.replace(innerExpr.full, String(result));
                }
                
                // 演算子の優先順位に従って評価
                const operators = [
                    ['||'],
                    ['&&'],
                    ['==', '!=', '===', '!=='],
                    ['<', '>', '<=', '>='],
                    ['+', '-'],
                    ['*', '/', '%']
                ];
                
                for (const opGroup of operators) {
                    for (const op of opGroup) {
                        const opIndex = this.findOperator(expr, op);
                        if (opIndex !== -1) {
                            const left = expr.substring(0, opIndex).trim();
                            const right = expr.substring(opIndex + op.length).trim();
                            
                            const leftVal = this.evaluateExpression(left, context);
                            const rightVal = this.evaluateExpression(right, context);
                            
                            return this.applyOperator(leftVal, op, rightVal);
                        }
                    }
                }
                
                // 単項演算子
                if (expr.startsWith('!')) {
                    return !this.evaluateExpression(expr.substring(1), context);
                }
                if (expr.startsWith('-')) {
                    return -this.evaluateExpression(expr.substring(1), context);
                }
                if (expr.startsWith('+')) {
                    return +this.evaluateExpression(expr.substring(1), context);
                }
                
                throw new Error(`評価できない式: ${expr}`);
            }
            
            // カンマ区切りの要素をパース
            parseCommaSeparated(str) {
                const elements = [];
                let current = '';
                let depth = 0;
                let inString = false;
                let stringChar = '';
                
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    
                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                    } else if (inString && char === stringChar) {
                        inString = false;
                    } else if (!inString) {
                        if (char === '(' || char === '[' || char === '{') {
                            depth++;
                        } else if (char === ')' || char === ']' || char === '}') {
                            depth--;
                        } else if (char === ',' && depth === 0) {
                            elements.push(current.trim());
                            current = '';
                            continue;
                        }
                    }
                    
                    current += char;
                }
                
                if (current.trim()) {
                    elements.push(current.trim());
                }
                
                return elements;
            }
            
            // 括弧内の式を抽出
            extractParentheses(expr) {
                const start = expr.indexOf('(');
                let depth = 1;
                let end = start + 1;
                
                while (end < expr.length && depth > 0) {
                    if (expr[end] === '(') depth++;
                    if (expr[end] === ')') depth--;
                    end++;
                }
                
                return {
                    full: expr.substring(start, end),
                    content: expr.substring(start + 1, end - 1)
                };
            }
            
            // 演算子の位置を検索
            findOperator(expr, operator) {
                let depth = 0;
                let inString = false;
                let stringChar = '';
                
                for (let i = expr.length - operator.length; i >= 0; i--) {
                    const char = expr[i];
                    
                    if (!inString && (char === '"' || char === "'")) {
                        inString = true;
                        stringChar = char;
                    } else if (inString && char === stringChar) {
                        inString = false;
                    } else if (!inString) {
                        if (char === ')' || char === ']' || char === '}') {
                            depth++;
                        } else if (char === '(' || char === '[' || char === '{') {
                            depth--;
                        } else if (depth === 0 && expr.substring(i, i + operator.length) === operator) {
                            return i;
                        }
                    }
                }
                
                return -1;
            }
            
            // 演算子を適用
            applyOperator(left, operator, right) {
                switch (operator) {
                    case '+': return left + right;
                    case '-': return left - right;
                    case '*': return left * right;
                    case '/': return left / right;
                    case '%': return left % right;
                    case '==': return left == right;
                    case '!=': return left != right;
                    case '===': return left === right;
                    case '!==': return left !== right;
                    case '<': return left < right;
                    case '>': return left > right;
                    case '<=': return left <= right;
                    case '>=': return left >= right;
                    case '&&': return left && right;
                    case '||': return left || right;
                    default: throw new Error(`未対応の演算子: ${operator}`);
                }
            }

            // 変数宣言の解析（複数行対応）
            parseVariableDeclaration(line, lineNumber, allLines, currentLineIndex) {
                // 単一行の場合
                const singleLinePatterns = [
                    /^\s*(let|var|const)\s+(\w+)\s*=\s*(.+);?\s*$/,
                    /^\s*(let|var|const)\s+(\w+)\s*;\s*$/
                ];
                
                for (const pattern of singleLinePatterns) {
                    const match = line.match(pattern);
                    if (match) {
                        const varType = match[1];
                        const varName = match[2];
                        const varValue = match[3];
                        
                        let value = undefined;
                        if (varValue) {
                            // オブジェクトや配列の開始をチェック
                            if (varValue.trim() === '{' || varValue.trim().startsWith('{') && !varValue.trim().endsWith('}')) {
                                // 複数行オブジェクトの場合
                                const objResult = this.parseMultiLineObject(allLines, currentLineIndex, varValue);
                                if (objResult) {
                                    try {
                                        value = this.safeEval(objResult.fullExpression);
                                    } catch (e) {
                                        value = objResult.fullExpression;
                                    }
                                    // 統一された変数設定メソッドを使用
                                    const result = this.setVariable(varName, value, lineNumber, 'declaration', varType);
                                    this.lineToVarMap.set(lineNumber, { name: varName, value: value, type: 'declaration' });
                                    return { varName, value, type: varType, endLine: objResult.endLine };
                                }
                            } else if (varValue.trim() === '[' || varValue.trim().startsWith('[') && !varValue.trim().endsWith(']')) {
                                // 複数行配列の場合
                                const arrResult = this.parseMultiLineArray(allLines, currentLineIndex, varValue);
                                if (arrResult) {
                                    try {
                                        value = this.safeEval(arrResult.fullExpression);
                                    } catch (e) {
                                        value = arrResult.fullExpression;
                                    }
                                    // 統一された変数設定メソッドを使用
                                    const result = this.setVariable(varName, value, lineNumber, 'declaration', varType);
                                    this.lineToVarMap.set(lineNumber, { name: varName, value: value, type: 'declaration' });
                                    return { varName, value, type: varType, endLine: arrResult.endLine };
                                }
                            } else {
                                // 通常の単一行処理
                                try {
                                    // セミコロンを除去
                                    let cleanVarValue = varValue;
                                    if (cleanVarValue.endsWith(';')) {
                                        cleanVarValue = cleanVarValue.slice(0, -1).trim();
                                    }
                                    value = this.safeEval(cleanVarValue, this.variables);
                                } catch (e) {
                                    value = varValue; // 評価できない場合は文字列として保存
                                }
                            }
                        }
                        
                        // 統一された変数設定メソッドを使用
                        const result = this.setVariable(varName, value, lineNumber, 'declaration', varType);
                        this.lineToVarMap.set(lineNumber, { name: varName, value: value, type: 'declaration' });
                        return { varName, value, type: varType };
                    }
                }
                return null;
            }
            
            // 複数行オブジェクトの解析
            parseMultiLineObject(lines, startIndex, initialValue) {
                let braceCount = 0;
                let fullExpression = '';
                let endLine = startIndex;
                
                // 最初の行の処理
                const firstLine = lines[startIndex].trim();
                const equalIndex = firstLine.indexOf('=');
                if (equalIndex !== -1) {
                    fullExpression = firstLine.substring(equalIndex + 1).trim();
                } else {
                    fullExpression = initialValue;
                }
                
                // ブレースをカウント
                for (const char of fullExpression) {
                    if (char === '{') braceCount++;
                    if (char === '}') braceCount--;
                }
                
                // 既に完了している場合
                if (braceCount === 0) {
                    return { fullExpression, endLine };
                }
                
                // 複数行を結合
                for (let i = startIndex + 1; i < lines.length && braceCount > 0; i++) {
                    const line = lines[i].trim();
                    fullExpression += ' ' + line;
                    
                    for (const char of line) {
                        if (char === '{') braceCount++;
                        if (char === '}') braceCount--;
                    }
                    
                    endLine = i;
                    
                    if (braceCount === 0) break;
                }
                
                return braceCount === 0 ? { fullExpression, endLine } : null;
            }
            
            // 複数行配列の解析
            parseMultiLineArray(lines, startIndex, initialValue) {
                let bracketCount = 0;
                let fullExpression = '';
                let endLine = startIndex;
                
                // 最初の行の処理
                const firstLine = lines[startIndex].trim();
                const equalIndex = firstLine.indexOf('=');
                if (equalIndex !== -1) {
                    fullExpression = firstLine.substring(equalIndex + 1).trim();
                } else {
                    fullExpression = initialValue;
                }
                
                // 括弧をカウント
                for (const char of fullExpression) {
                    if (char === '[') bracketCount++;
                    if (char === ']') bracketCount--;
                }
                
                // 既に完了している場合
                if (bracketCount === 0) {
                    return { fullExpression, endLine };
                }
                
                // 複数行を結合
                for (let i = startIndex + 1; i < lines.length && bracketCount > 0; i++) {
                    const line = lines[i].trim();
                    fullExpression += ' ' + line;
                    
                    for (const char of line) {
                        if (char === '[') bracketCount++;
                        if (char === ']') bracketCount--;
                    }
                    
                    endLine = i;
                    
                    if (bracketCount === 0) break;
                }
                
                return bracketCount === 0 ? { fullExpression, endLine } : null;
            }
            
            // 関数定義の解析
            parseFunctionDeclaration(line, lineNumber) {
                // function名前(引数) の形式
                const functionMatch = line.match(/^\s*function\s+(\w+)\s*\(([^)]*)\)\s*\{?\s*$/);
                if (functionMatch) {
                    const funcName = functionMatch[1];
                    const paramsStr = functionMatch[2].trim();
                    const params = paramsStr ? paramsStr.split(',').map(p => p.trim()) : [];
                    
                    // 関数オブジェクトを作成
                    const functionObj = {
                        name: funcName,
                        params: params,
                        startLine: lineNumber,
                        endLine: null, // 後で設定
                        body: [],
                        type: 'function'
                    };
                    
                    this.functions.set(funcName, functionObj);
                    
                    // 関数名を変数として登録
                    this.setVariable(funcName, functionObj, lineNumber, 'function_declaration');
                    
                    return { type: 'function_declaration', name: funcName, params: params };
                }
                
                // アロー関数の基本形: const name = (params) => { 
                const arrowMatch = line.match(/^\s*(let|var|const)\s+(\w+)\s*=\s*\(([^)]*)\)\s*=>\s*\{?\s*$/);
                if (arrowMatch) {
                    const varType = arrowMatch[1];
                    const funcName = arrowMatch[2];
                    const paramsStr = arrowMatch[3].trim();
                    const params = paramsStr ? paramsStr.split(',').map(p => p.trim()) : [];
                    
                    const functionObj = {
                        name: funcName,
                        params: params,
                        startLine: lineNumber,
                        endLine: null,
                        body: [],
                        type: 'arrow_function'
                    };
                    
                    this.functions.set(funcName, functionObj);
                    this.setVariable(funcName, functionObj, lineNumber, 'function_declaration', varType);
                    
                    return { type: 'arrow_function_declaration', name: funcName, params: params };
                }
                
                // 単一式アロー関数: const name = (params) => expression
                const singleArrowMatch = line.match(/^\s*(let|var|const)\s+(\w+)\s*=\s*\(([^)]*)\)\s*=>\s*(.+);?\s*$/);
                if (singleArrowMatch) {
                    const varType = singleArrowMatch[1];
                    const funcName = singleArrowMatch[2];
                    const paramsStr = singleArrowMatch[3].trim();
                    const expression = singleArrowMatch[4].trim();
                    const params = paramsStr ? paramsStr.split(',').map(p => p.trim()) : [];
                    
                    const functionObj = {
                        name: funcName,
                        params: params,
                        startLine: lineNumber,
                        endLine: lineNumber,
                        body: [`return ${expression}`],
                        type: 'single_arrow_function'
                    };
                    
                    this.functions.set(funcName, functionObj);
                    this.setVariable(funcName, functionObj, lineNumber, 'function_declaration', varType);
                    
                    return { type: 'single_arrow_function_declaration', name: funcName, params: params, expression: expression };
                }
                
                return null;
            }
            
            // 関数呼び出しの解析
            parseFunctionCall(line, lineNumber) {
                // 基本的な関数呼び出し: functionName(args)
                const callMatch = line.match(/^\s*(\w+)\s*\(([^)]*)\)\s*;?\s*$/);
                if (callMatch) {
                    const funcName = callMatch[1];
                    const argsStr = callMatch[2].trim();
                    const args = argsStr ? this.parseCommaSeparated(argsStr) : [];
                    
                    return { type: 'function_call', name: funcName, args: args };
                }
                
                // 変数への代入: const result = functionName(args)
                const assignCallMatch = line.match(/^\s*(let|var|const)\s+(\w+)\s*=\s*(\w+)\s*\(([^)]*)\)\s*;?\s*$/);
                if (assignCallMatch) {
                    const varType = assignCallMatch[1];
                    const varName = assignCallMatch[2];
                    const funcName = assignCallMatch[3];
                    const argsStr = assignCallMatch[4].trim();
                    const args = argsStr ? this.parseCommaSeparated(argsStr) : [];
                    
                    return { type: 'function_call_assignment', varType: varType, varName: varName, funcName: funcName, args: args };
                }
                
                // 既存変数への代入: variable = functionName(args)
                const varAssignCallMatch = line.match(/^\s*(\w+)\s*=\s*(\w+)\s*\(([^)]*)\)\s*;?\s*$/);
                if (varAssignCallMatch) {
                    const varName = varAssignCallMatch[1];
                    const funcName = varAssignCallMatch[2];
                    const argsStr = varAssignCallMatch[3].trim();
                    const args = argsStr ? this.parseCommaSeparated(argsStr) : [];
                    
                    return { type: 'function_call_var_assignment', varName: varName, funcName: funcName, args: args };
                }
                
                return null;
            }
            
            // 関数を実行
            async executeFunction(funcName, args, lineNumber) {
                const func = this.functions.get(funcName);
                if (!func) {
                    throw new Error(`未定義の関数: ${funcName}`);
                }
                
                // 新しいスコープを作成
                const functionScope = this.pushScope('function', funcName);
                
                // 引数を関数スコープに設定
                for (let i = 0; i < func.params.length; i++) {
                    const paramName = func.params[i];
                    const argValue = i < args.length ? args[i] : undefined;
                    
                    // 引数の値を評価
                    let evaluatedArg;
                    try {
                        evaluatedArg = this.safeEval(argValue);
                    } catch (e) {
                        evaluatedArg = argValue;
                    }
                    
                    functionScope.variables[paramName] = { value: evaluatedArg, type: 'parameter', constant: false };
                }
                
                // 関数呼び出しスタックに追加
                this.callStack.push({
                    name: funcName,
                    args: args,
                    startLine: lineNumber,
                    returnValue: undefined
                });
                
                let returnValue = undefined;
                
                try {
                    if (func.type === 'single_arrow_function') {
                        // 単一式アロー関数の場合、式を評価して返す
                        const expression = func.body[0].replace('return ', '');
                        returnValue = this.safeEval(expression);
                    } else {
                        // 通常の関数の場合、関数本体を実行
                        // これは複雑なため、基本的な処理のみ実装
                        returnValue = `[Function ${funcName} executed]`;
                    }
                } catch (e) {
                    throw new Error(`関数 ${funcName} の実行エラー: ${e.message}`);
                } finally {
                    // スコープとコールスタックをクリーンアップ
                    this.popScope();
                    this.callStack.pop();
                }
                
                return returnValue;
            }
            
            // return文の解析
            parseReturn(line, lineNumber) {
                const returnMatch = line.match(/^\s*return(\s+(.+))?\s*;?\s*$/);
                if (returnMatch) {
                    const returnExpr = returnMatch[2];
                    let returnValue = undefined;
                    
                    if (returnExpr) {
                        try {
                            returnValue = this.safeEval(returnExpr.trim());
                        } catch (e) {
                            returnValue = returnExpr.trim();
                        }
                    }
                    
                    this.returnFlag = true;
                    this.returnValue = returnValue;
                    
                    return { type: 'return', value: returnValue };
                }
                return null;
            }

            // 代入の解析
            parseAssignment(line, lineNumber) {
                const patterns = [
                    /^\s*(\w+)\s*=\s*(.+);?\s*$/,
                    /^\s*(\w+)\s*(\+=|-=|\*=|\/=|%=)\s*(.+);?\s*$/,  // 複合代入演算子
                    /^\s*(\w+)\s*(\+\+|--)\s*;?\s*$/,
                    /^\s*(\+\+|--)(\w+)\s*;?\s*$/,
                    /^\s*(\w+)\[(.+)\]\s*=\s*(.+);?\s*$/  // 配列要素への代入
                ];
                
                // 通常の代入
                const assignMatch = line.match(patterns[0]);
                if (assignMatch) {
                    const varName = assignMatch[1];
                    let varValue = assignMatch[2].trim();
                    
                    // 末尾のセミコロンを除去
                    if (varValue.endsWith(';')) {
                        varValue = varValue.slice(0, -1).trim();
                    }
                    
                    try {
                        const value = this.safeEval(varValue, this.variables);
                        const result = this.setVariable(varName, value, lineNumber, 'assignment');
                        this.lineToVarMap.set(lineNumber, { name: varName, value: value, type: 'assignment' });
                        return result;
                    } catch (e) {
                        throw new Error(`代入エラー: ${e.message}`);
                    }
                }
                
                // 複合代入演算子（+=, -=, *=, /=, %=）
                const compoundMatch = line.match(patterns[1]);
                if (compoundMatch) {
                    const varName = compoundMatch[1];
                    const operator = compoundMatch[2];
                    let rightValue = compoundMatch[3].trim();
                    
                    // 末尾のセミコロンを除去
                    if (rightValue.endsWith(';')) {
                        rightValue = rightValue.slice(0, -1).trim();
                    }
                    
                    if (this.variables[varName] !== undefined) {
                        try {
                            const currentValue = this.variables[varName];
                            const rightVal = this.safeEval(rightValue, this.variables);
                            let newValue;
                            
                            switch (operator) {
                                case '+=':
                                    newValue = currentValue + rightVal;
                                    break;
                                case '-=':
                                    newValue = currentValue - rightVal;
                                    break;
                                case '*=':
                                    newValue = currentValue * rightVal;
                                    break;
                                case '/=':
                                    newValue = currentValue / rightVal;
                                    break;
                                case '%=':
                                    newValue = currentValue % rightVal;
                                    break;
                                default:
                                    throw new Error(`未対応の演算子: ${operator}`);
                            }
                            
                            const result = this.setVariable(varName, newValue, lineNumber, 'compound_assignment');
                            this.lineToVarMap.set(lineNumber, { name: varName, value: newValue, type: 'compound_assignment' });
                            return result;
                        } catch (e) {
                            throw new Error(`複合代入エラー: ${e.message}`);
                        }
                    } else {
                        throw new Error(`未定義の変数: ${varName}`);
                    }
                }
                
                // インクリメント/デクリメント
                // 後置：変数++, 変数--
                const postIncMatch = line.match(patterns[2]);
                if (postIncMatch) {
                    const varName = postIncMatch[1];
                    const operator = postIncMatch[2];
                    
                    if (this.variables[varName] !== undefined) {
                        const currentValue = this.variables[varName];
                        const newValue = operator === '++' ? currentValue + 1 : currentValue - 1;
                        const result = this.setVariable(varName, newValue, lineNumber, 'increment');
                        this.lineToVarMap.set(lineNumber, { name: varName, value: newValue, type: 'increment' });
                        return result;
                    } else {
                        throw new Error(`未定義の変数: ${varName}`);
                    }
                }
                
                // 前置：++変数, --変数
                const preIncMatch = line.match(patterns[3]);
                if (preIncMatch) {
                    const operator = preIncMatch[1];
                    const varName = preIncMatch[2];
                    
                    if (this.variables[varName] !== undefined) {
                        const currentValue = this.variables[varName];
                        const newValue = operator === '++' ? currentValue + 1 : currentValue - 1;
                        const result = this.setVariable(varName, newValue, lineNumber, 'increment');
                        this.lineToVarMap.set(lineNumber, { name: varName, value: newValue, type: 'increment' });
                        return result;
                    } else {
                        throw new Error(`未定義の変数: ${varName}`);
                    }
                }
                
                // 配列要素への代入: arrayName[index] = value
                const arrayAssignMatch = line.match(patterns[4]);
                if (arrayAssignMatch) {
                    const arrayName = arrayAssignMatch[1];
                    const indexExpr = arrayAssignMatch[2];
                    const valueExpr = arrayAssignMatch[3].trim();
                    
                    if (this.variables[arrayName] !== undefined && Array.isArray(this.variables[arrayName])) {
                        try {
                            // インデックスを評価
                            const index = this.safeEval(indexExpr, this.variables);
                            // 値を評価
                            const value = this.safeEval(valueExpr, this.variables);
                            
                            // 配列のコピーを作成して要素を更新
                            const newArray = [...this.variables[arrayName]];
                            newArray[index] = value;
                            
                            // 配列全体を更新
                            const result = this.setVariable(arrayName, newArray, lineNumber, 'array_assignment');
                            this.lineToVarMap.set(lineNumber, { name: arrayName, value: newArray, type: 'array_assignment' });
                            return result;
                        } catch (e) {
                            throw new Error(`配列要素代入エラー: ${e.message}`);
                        }
                    } else {
                        throw new Error(`未定義の配列または配列ではない変数: ${arrayName}`);
                    }
                }
                
                return null;
            }

            // console.log の解析
            parseConsoleLog(line) {
                const match = line.match(/console\.log\s*\(\s*(.+)\s*\)/);
                if (match) {
                    const args = match[1];
                    try {
                        const result = this.safeEval(args, this.variables);
                        return String(result);
                    } catch (e) {
                        // 複数引数の場合の簡易処理
                        const parts = args.split('+').map(part => {
                            part = part.trim();
                            if (part.startsWith('"') && part.endsWith('"')) {
                                return part.slice(1, -1);
                            } else if (this.variables[part] !== undefined) {
                                return String(this.variables[part]);
                            } else {
                                return part;
                            }
                        });
                        return parts.join('');
                    }
                }
                return null;
            }

            // 条件分岐の解析（改良版）
            parseCondition(line) {
                // if文のパターン
                const ifMatch = line.match(/^\s*if\s*\(\s*(.+)\s*\)\s*\{?\s*$/);
                if (ifMatch) {
                    const condition = ifMatch[1];
                    try {
                        const result = this.safeEval(condition, this.variables);
                        return { type: 'if', condition: condition, result: Boolean(result) };
                    } catch (e) {
                        return { type: 'if', condition: condition, result: false, error: e.message };
                    }
                }
                
                // else if文のパターン（複数のパターンに対応）
                const elseIfPatterns = [
                    /^\s*}\s*else\s+if\s*\(\s*(.+)\s*\)\s*\{?\s*$/,  // } else if (condition) {
                    /^\s*else\s+if\s*\(\s*(.+)\s*\)\s*\{?\s*$/       // else if (condition) {
                ];
                
                for (const pattern of elseIfPatterns) {
                    const elseIfMatch = line.match(pattern);
                    if (elseIfMatch) {
                        const condition = elseIfMatch[1];
                        try {
                            const result = this.safeEval(condition, this.variables);
                            return { type: 'elseif', condition: condition, result: Boolean(result) };
                        } catch (e) {
                            return { type: 'elseif', condition: condition, result: false, error: e.message };
                        }
                    }
                }
                
                // else文のパターン（複数のパターンに対応）
                const elsePatterns = [
                    /^\s*}\s*else\s*\{?\s*$/,  // } else {
                    /^\s*else\s*\{?\s*$/       // else {
                ];
                
                for (const pattern of elsePatterns) {
                    if (line.match(pattern)) {
                        return { type: 'else' };
                    }
                }
                
                return null;
            }

            // ループの解析
            parseLoop(line) {
                const forMatch = line.match(/^\s*for\s*\(\s*(.+)\s*\)\s*\{?\s*$/);
                if (forMatch) {
                    const forParts = forMatch[1].split(';').map(part => part.trim());
                    if (forParts.length === 3) {
                        return {
                            type: 'for',
                            init: forParts[0],
                            condition: forParts[1],
                            increment: forParts[2]
                        };
                    }
                }
                
                const whileMatch = line.match(/^\s*while\s*\(\s*(.+)\s*\)\s*\{?\s*$/);
                if (whileMatch) {
                    return {
                        type: 'while',
                        condition: whileMatch[1]
                    };
                }
                
                const doWhileMatch = line.match(/^\s*do\s*\{?\s*$/);
                if (doWhileMatch) {
                    return {
                        type: 'do_while_start'
                    };
                }
                
                const doWhileEndMatch = line.match(/^\s*\}\s*while\s*\(\s*(.+)\s*\)\s*;?\s*$/);
                if (doWhileEndMatch) {
                    return {
                        type: 'do_while_end',
                        condition: doWhileEndMatch[1]
                    };
                }
                
                return null;
            }
            
            // switch文の解析
            parseSwitch(line) {
                const switchMatch = line.match(/^\s*switch\s*\(\s*(.+)\s*\)\s*\{?\s*$/);
                if (switchMatch) {
                    return {
                        type: 'switch',
                        expression: switchMatch[1]
                    };
                }
                
                const caseMatch = line.match(/^\s*case\s+(.+)\s*:\s*$/);
                if (caseMatch) {
                    return {
                        type: 'case',
                        value: caseMatch[1]
                    };
                }
                
                const defaultMatch = line.match(/^\s*default\s*:\s*$/);
                if (defaultMatch) {
                    return {
                        type: 'default'
                    };
                }
                
                return null;
            }
            
            // 制御フロー文の解析
            parseControlFlow(line) {
                // break文
                const breakMatch = line.match(/^\s*break\s*;?\s*$/);
                if (breakMatch) {
                    this.breakFlag = true;
                    return { type: 'break' };
                }
                
                // continue文
                const continueMatch = line.match(/^\s*continue\s*;?\s*$/);
                if (continueMatch) {
                    this.continueFlag = true;
                    return { type: 'continue' };
                }
                
                return null;
            }

            // forループの初期化処理
            executeForInit(initStatement, lineNumber) {
                let cleanStatement = initStatement.trim();
                if (cleanStatement.endsWith(';')) {
                    cleanStatement = cleanStatement.slice(0, -1).trim();
                }
                
                if (cleanStatement.includes('let ') || cleanStatement.includes('var ') || cleanStatement.includes('const ')) {
                    const result = this.parseVariableDeclaration(cleanStatement, lineNumber);
                    if (result) {
                        return result;
                    }
                } else if (cleanStatement.includes('=')) {
                    const result = this.parseAssignment(cleanStatement, lineNumber);
                    if (result) {
                        return result;
                    }
                }
                return null;
            }

            // ループ条件の評価
            evaluateLoopCondition(condition) {
                try {
                    // 条件式をクリーンアップ
                    let cleanCondition = condition.trim();
                    if (cleanCondition.endsWith(';')) {
                        cleanCondition = cleanCondition.slice(0, -1).trim();
                    }
                    return Boolean(this.safeEval(cleanCondition, this.variables));
                } catch (e) {
                    console.warn('ループ条件の評価エラー:', e.message);
                    return false; // エラーの場合はループを終了
                }
            }

            // forループのインクリメント実行
            executeForIncrement(incrementStatement, lineNumber) {
                try {
                    let cleanStatement = incrementStatement.trim();
                    if (cleanStatement.endsWith(';')) {
                        cleanStatement = cleanStatement.slice(0, -1).trim();
                    }
                    
                    // インクリメント/デクリメント構文を優先的に処理
                    const incMatch = cleanStatement.match(/(\w+)\s*(\+\+|--)/);
                    if (incMatch) {
                        const varName = incMatch[1];
                        const operator = incMatch[2];
                        
                        if (this.variables[varName] !== undefined) {
                            const currentValue = this.variables[varName];
                            const newValue = operator === '++' ? currentValue + 1 : currentValue - 1;
                            const result = this.setVariable(varName, newValue, lineNumber, 'increment');
                            return result;
                        }
                    }
                    
                    // 通常の代入パターン
                    const result = this.parseAssignment(cleanStatement, lineNumber);
                    if (result) {
                        return result;
                    }
                    
                } catch (e) {
                    console.warn('インクリメント処理エラー:', e.message);
                }
                return null;
            }
        }

        // コードをステップごとに実行
        async function executeCodeStepByStep(code) {
            // リセット
            variableTracker.reset();
            isInMultiLineComment = false; // コメント状態をリセット
            const analyzer = new CodeAnalyzer(variableTracker, variables);
            const lines = code.split('\n');
            variables = {};
            
            // console.logの置き換え
            const originalConsoleLog = console.log;
            console.log = function(...args) {
                addConsoleOutput(args.join(' '));
            };
            
            try {
                let lineIndex = 0;
                let conditionStack = []; // 条件分岐のスタック
                let loopStack = []; // ループスタック
                let skipExecution = false; // 実行をスキップするかどうか
                const MAX_LOOP_ITERATIONS = 1000; // 無限ループ防止
                
                while (lineIndex < lines.length) {
                    // 実行中断チェック
                    if (executionAborted) {
                        throw new Error('実行が中断されました');
                    }
                    
                    const line = lines[lineIndex].trim();
                    const actualLineNumber = lineIndex + 1;
                    
                    // 空行やコメントをスキップ
                    if (isCommentLine(line)) {
                        lineIndex++;
                        continue;
                    }
                    
                    // コメントを除去してコード部分のみを取得
                    const codeOnly = removeComments(line);
                    if (!codeOnly) {
                        lineIndex++;
                        continue;
                    }
                    
                    await waitForNextStep();
                    highlightCodeLine(actualLineNumber, 800);
                    await animationDelay(800);
                    
                    try {
                        // ループの処理
                        const loopResult = analyzer.parseLoop(codeOnly);
                        if (loopResult) {
                            if (loopResult.type === 'for') {
                                // forループの場合、すでに初期化済みかチェック
                                const existingLoop = loopStack.find(loop => 
                                    loop.type === 'for' && loop.startLine === lineIndex
                                );
                                
                                if (!existingLoop) {
                                    // 初回のみ初期化を実行
                                    const initResult = analyzer.executeForInit(loopResult.init, actualLineNumber);
                                    if (initResult) {
                                        updateVariableOverlay(actualLineNumber, initResult.varName, initResult.value);
                                    }
                                    
                                    // ループ情報をスタックにプッシュ
                                    loopStack.push({
                                        type: 'for',
                                        startLine: lineIndex,
                                        condition: loopResult.condition,
                                        increment: loopResult.increment,
                                        iterationCount: 0,
                                        initialized: true  // 初期化済みフラグ
                                    });
                                }
                                
                                // ループ条件をチェック
                                const conditionResult = analyzer.evaluateLoopCondition(loopResult.condition);
                                if (!conditionResult) {
                                    // 条件が偽の場合、ループをスキップ
                                    let braceCount = 0;
                                    let tempIndex = lineIndex + 1;
                                    while (tempIndex < lines.length) {
                                        const tempLine = lines[tempIndex].trim();
                                        if (tempLine.includes('{')) braceCount++;
                                        if (tempLine.includes('}')) {
                                            braceCount--;
                                            if (braceCount <= 0) {
                                                lineIndex = tempIndex;
                                                break;
                                            }
                                        }
                                        tempIndex++;
                                    }
                                    // 条件が偽の場合はループスタックから削除
                                    const loopToRemove = loopStack.findIndex(loop => 
                                        loop.type === 'for' && loop.startLine === lineIndex
                                    );
                                    if (loopToRemove !== -1) {
                                        loopStack.splice(loopToRemove, 1);
                                    }
                                }
                            } else if (loopResult.type === 'while') {
                                // whileループの処理
                                loopStack.push({
                                    type: 'while',
                                    startLine: lineIndex,
                                    condition: loopResult.condition,
                                    iterationCount: 0
                                });
                                
                                const conditionResult = analyzer.evaluateLoopCondition(loopResult.condition);
                                if (!conditionResult) {
                                    // 条件が偽の場合、ループをスキップ
                                    let braceCount = 0;
                                    let tempIndex = lineIndex + 1;
                                    while (tempIndex < lines.length) {
                                        const tempLine = lines[tempIndex].trim();
                                        if (tempLine.includes('{')) braceCount++;
                                        if (tempLine.includes('}')) {
                                            braceCount--;
                                            if (braceCount <= 0) {
                                                lineIndex = tempIndex;
                                                break;
                                            }
                                        }
                                        tempIndex++;
                                    }
                                    loopStack.pop();
                                }
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // 条件分岐の処理（改良版）
                        const conditionResult = analyzer.parseCondition(codeOnly);
                        if (conditionResult) {
                            if (conditionResult.type === 'if') {
                                // if文の開始
                                const conditionInfo = {
                                    type: 'if-block',
                                    hasExecuted: conditionResult.result, // 既に実行したブロックがあるか
                                    currentCondition: conditionResult.result
                                };
                                conditionStack.push(conditionInfo);
                                skipExecution = !conditionResult.result;
                                
                                // デバッグ用オーバーレイ
                                updateVariableOverlay(actualLineNumber, 'if', 
                                    `${conditionResult.condition} → ${conditionResult.result ? '実行' : 'スキップ'}`);
                                
                            } else if (conditionResult.type === 'elseif') {
                                if (conditionStack.length > 0 && conditionStack[conditionStack.length - 1].type === 'if-block') {
                                    const ifBlock = conditionStack[conditionStack.length - 1];
                                    
                                    // 前のif/else ifが実行されていない場合のみ、この条件をチェック
                                    const shouldExecute = !ifBlock.hasExecuted && conditionResult.result;
                                    
                                    if (shouldExecute) {
                                        ifBlock.hasExecuted = true; // この分岐を実行することをマーク
                                    }
                                    
                                    skipExecution = !shouldExecute;
                                    
                                    // デバッグ用オーバーレイ
                                    updateVariableOverlay(actualLineNumber, 'else if', 
                                        `${conditionResult.condition} → ${shouldExecute ? '実行' : 'スキップ'}`);
                                }
                                
                            } else if (conditionResult.type === 'else') {
                                if (conditionStack.length > 0 && conditionStack[conditionStack.length - 1].type === 'if-block') {
                                    const ifBlock = conditionStack[conditionStack.length - 1];
                                    
                                    // 前のif/else ifが実行されていない場合のみ、elseを実行
                                    const shouldExecute = !ifBlock.hasExecuted;
                                    
                                    if (shouldExecute) {
                                        ifBlock.hasExecuted = true;
                                    }
                                    
                                    skipExecution = !shouldExecute;
                                    
                                    // デバッグ用オーバーレイ
                                    updateVariableOverlay(actualLineNumber, 'else', 
                                        shouldExecute ? '実行' : 'スキップ');
                                }
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // 関数定義の処理
                        const functionDeclaration = analyzer.parseFunctionDeclaration(codeOnly, actualLineNumber);
                        if (functionDeclaration) {
                            updateVariableOverlay(actualLineNumber, functionDeclaration.name, '[Function]');
                            lineIndex++;
                            continue;
                        }
                        
                        // 関数呼び出しの処理
                        const functionCall = analyzer.parseFunctionCall(codeOnly, actualLineNumber);
                        if (functionCall) {
                            try {
                                if (functionCall.type === 'function_call') {
                                    const result = await analyzer.executeFunction(functionCall.name, functionCall.args, actualLineNumber);
                                    // 関数呼び出しの結果をコンソールに表示（必要に応じて）
                                } else if (functionCall.type === 'function_call_assignment') {
                                    const result = await analyzer.executeFunction(functionCall.funcName, functionCall.args, actualLineNumber);
                                    analyzer.setVariable(functionCall.varName, result, actualLineNumber, 'assignment', functionCall.varType);
                                    updateVariableOverlay(actualLineNumber, functionCall.varName, result);
                                } else if (functionCall.type === 'function_call_var_assignment') {
                                    const result = await analyzer.executeFunction(functionCall.funcName, functionCall.args, actualLineNumber);
                                    analyzer.setVariable(functionCall.varName, result, actualLineNumber, 'assignment');
                                    updateVariableOverlay(actualLineNumber, functionCall.varName, result);
                                }
                            } catch (e) {
                                addConsoleOutput(`関数呼び出しエラー: ${e.message}`, 'error');
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // return文の処理
                        const returnResult = analyzer.parseReturn(codeOnly, actualLineNumber);
                        if (returnResult) {
                            updateVariableOverlay(actualLineNumber, 'return', returnResult.value);
                            addConsoleOutput(`return: ${returnResult.value}`);
                            // return文が実行されたら関数から抜ける（簡易実装）
                            lineIndex++;
                            continue;
                        }
                        
                        // switch文の処理
                        const switchResult = analyzer.parseSwitch(codeOnly);
                        if (switchResult) {
                            if (switchResult.type === 'switch') {
                                // switch式を評価してスタックに保存
                                try {
                                    const switchValue = analyzer.safeEval(switchResult.expression);
                                    conditionStack.push({ 
                                        type: 'switch', 
                                        value: switchValue, 
                                        matched: false,
                                        executing: false,  // 現在実行中かどうか
                                        hasMatched: false  // 一度でもマッチしたかどうか
                                    });
                                    updateVariableOverlay(actualLineNumber, 'switch', switchValue);
                                } catch (e) {
                                    addConsoleOutput(`switch式エラー: ${e.message}`, 'error');
                                }
                            } else if (switchResult.type === 'case') {
                                if (conditionStack.length > 0 && conditionStack[conditionStack.length - 1].type === 'switch') {
                                    const switchInfo = conditionStack[conditionStack.length - 1];
                                    try {
                                        const caseValue = analyzer.safeEval(switchResult.value);
                                        
                                        // 値が一致するか、または既にfall-through中かをチェック
                                        const isMatch = switchInfo.value === caseValue;
                                        
                                        if (isMatch && !switchInfo.hasMatched) {
                                            // 最初のマッチ
                                            switchInfo.matched = true;
                                            switchInfo.executing = true;
                                            switchInfo.hasMatched = true;
                                            skipExecution = false;
                                        } else if (switchInfo.executing) {
                                            // fall-through中
                                            switchInfo.matched = true;
                                            skipExecution = false;
                                        } else {
                                            // マッチしない、かつfall-through中でもない
                                            switchInfo.matched = false;
                                            skipExecution = true;
                                        }
                                        
                                        updateVariableOverlay(actualLineNumber, 'case', `${caseValue} ${switchInfo.matched ? '✓' : '✗'}`);
                                    } catch (e) {
                                        addConsoleOutput(`case評価エラー: ${e.message}`, 'error');
                                    }
                                }
                            } else if (switchResult.type === 'default') {
                                if (conditionStack.length > 0 && conditionStack[conditionStack.length - 1].type === 'switch') {
                                    const switchInfo = conditionStack[conditionStack.length - 1];
                                    
                                    // default節は、まだマッチしていない場合またはfall-through中の場合に実行
                                    if (!switchInfo.hasMatched || switchInfo.executing) {
                                        switchInfo.executing = true;
                                        skipExecution = false;
                                        updateVariableOverlay(actualLineNumber, 'default', '実行');
                                    } else {
                                        skipExecution = true;
                                        updateVariableOverlay(actualLineNumber, 'default', 'スキップ');
                                    }
                                }
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // 制御フロー文の処理
                        const controlFlow = analyzer.parseControlFlow(codeOnly);
                        if (controlFlow) {
                            if (controlFlow.type === 'break') {
                                // break文の処理を改善
                                let breakHandled = false;
                                
                                // switch文内のbreakをチェック
                                if (conditionStack.length > 0 && conditionStack[conditionStack.length - 1].type === 'switch') {
                                    const switchInfo = conditionStack[conditionStack.length - 1];
                                    switchInfo.executing = false; // switch実行を停止
                                    skipExecution = true; // 後続のcase文をスキップ
                                    updateVariableOverlay(actualLineNumber, 'break', 'Switch終了');
                                    breakHandled = true;
                                }
                                // ループ内のbreakをチェック
                                else if (loopStack.length > 0) {
                                    updateVariableOverlay(actualLineNumber, 'break', 'ループ終了');
                                    // ループから抜ける処理
                                    let braceCount = 0;
                                    let tempIndex = lineIndex + 1;
                                    while (tempIndex < lines.length) {
                                        const tempLine = lines[tempIndex].trim();
                                        if (tempLine.includes('{')) braceCount++;
                                        if (tempLine.includes('}')) {
                                            braceCount--;
                                            if (braceCount <= 0) {
                                                lineIndex = tempIndex;
                                                break;
                                            }
                                        }
                                        tempIndex++;
                                    }
                                    loopStack.pop(); // ループスタックからポップ
                                    breakHandled = true;
                                }
                                
                                if (!breakHandled) {
                                    updateVariableOverlay(actualLineNumber, 'break', '無効');
                                }
                            } else if (controlFlow.type === 'continue') {
                                updateVariableOverlay(actualLineNumber, 'continue', '次の反復');
                                // continue処理（簡易実装）
                                if (loopStack.length > 0) {
                                    const currentLoop = loopStack[loopStack.length - 1];
                                    lineIndex = currentLoop.startLine - 1; // ループの開始に戻る（-1は次のincrementで調整）
                                }
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // ブロックの終了
                        if (codeOnly === '}') {
                            // ループの終了処理
                            if (loopStack.length > 0) {
                                const currentLoop = loopStack[loopStack.length - 1];
                                currentLoop.iterationCount++;
                                
                                // 無限ループ防止
                                if (currentLoop.iterationCount > MAX_LOOP_ITERATIONS) {
                                    addConsoleOutput('警告: ループの実行回数が上限に達しました', 'warning');
                                    loopStack.pop();
                                    lineIndex++;
                                    continue;
                                }
                                
                                if (currentLoop.type === 'for') {
                                    // forループのインクリメント実行
                                    const incrementResult = analyzer.executeForIncrement(currentLoop.increment, actualLineNumber);
                                    if (incrementResult) {
                                        // forループの行にインクリメント後の値を表示（ループカウンタの進行を可視化）
                                        const forLineNumber = currentLoop.startLine + 1; // startLineは0ベースなので+1
                                        updateVariableOverlay(forLineNumber, incrementResult.varName, incrementResult.value);
                                    }
                                }
                                
                                // ループ条件の再評価
                                const conditionResult = analyzer.evaluateLoopCondition(currentLoop.condition);
                                
                                
                                if (conditionResult) {
                                    // 条件が真の場合、ループの開始に戻る
                                    lineIndex = currentLoop.startLine;
                                    continue;
                                } else {
                                    // 条件が偽の場合、ループを終了
                                    loopStack.pop();
                                }
                            }
                            
                            // 条件分岐の終了処理
                            if (conditionStack.length > 0) {
                                const lastCondition = conditionStack[conditionStack.length - 1];
                                if (lastCondition && lastCondition.type === 'switch') {
                                    // switch文の終了
                                    conditionStack.pop();
                                } else if (lastCondition && lastCondition.type === 'if-block') {
                                    // if-else ifブロックの終了
                                    conditionStack.pop();
                                } else {
                                    // 通常の条件分岐の終了
                                    conditionStack.pop();
                                }
                                skipExecution = false;
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // 実行をスキップする場合
                        if (skipExecution) {
                            lineIndex++;
                            continue;
                        }
                        
                        // 変数宣言の処理
                        const varDeclaration = analyzer.parseVariableDeclaration(codeOnly, actualLineNumber, lines, lineIndex);
                        if (varDeclaration) {
                            updateVariableOverlay(actualLineNumber, varDeclaration.varName, varDeclaration.value);
                            // 複数行の場合はendLineまでスキップ
                            if (varDeclaration.endLine && varDeclaration.endLine > lineIndex) {
                                lineIndex = varDeclaration.endLine;
                            }
                            lineIndex++;
                            continue;
                        }
                        
                        // 代入の処理
                        const assignment = analyzer.parseAssignment(codeOnly, actualLineNumber);
                        if (assignment) {
                            updateVariableOverlay(actualLineNumber, assignment.varName, assignment.value);
                            lineIndex++;
                            continue;
                        }
                        
                        // console.log の処理
                        const consoleResult = analyzer.parseConsoleLog(codeOnly);
                        if (consoleResult) {
                            addConsoleOutput(consoleResult);
                            lineIndex++;
                            continue;
                        }
                        
                        // その他の文（処理をスキップ）
                        lineIndex++;
                        
                    } catch (e) {
                        addConsoleOutput(`行 ${actualLineNumber} でエラー: ${e.message}`, 'error');
                        lineIndex++;
                    }
                }
                
            } finally {
                console.log = originalConsoleLog;
            }
        }

        // リセット機能
        function resetExecution(full = true) {
            // フルリセット時のみ実行中断フラグを設定
            if (full) {
                executionAborted = true;
            }
            
            // 実行中の全てのタイムアウトをクリア
            currentTimeouts.forEach(timeoutId => {
                clearTimeout(timeoutId);
            });
            currentTimeouts.clear();
            
            // スクロールタイムアウトもクリア
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
                scrollTimeout = null;
            }
            
            if (isProcessing && full) {
                isProcessing = false;
                stepWaiting = false;
                
                // 待機中のPromiseを解決
                if (nextStepResolve) {
                    nextStepResolve();
                    nextStepResolve = null;
                }
                
                currentStep = 0;
                
                document.getElementById('executeBtn').disabled = false;
                document.getElementById('nextStepBtn').style.display = 'none';
                document.getElementById('stepInfo').style.display = 'none';
            }
            
            if (full) {
                variables = {};
                variableTracker.reset();
                errorManager.clear(); // エラーマネージャーもクリア
                clearConsole();
                displayCode(document.getElementById('codeInput').value);
                
                // フルリセット時は中断フラグを即座にリセット
                executionAborted = false;
            }
            
            resetCodeHighlight();
            resetVariableOverlays();
            updateExecutionModeUI();
        }

        // 実行結果パネルのトグル機能
        function toggleOutputPanel() {
            const rightPanel = document.getElementById('rightPanel');
            const outputSection = rightPanel.querySelector('.output-section');
            const expandBtn = rightPanel.querySelector('.panel-expand-btn');
            const toggleBtn = rightPanel.querySelector('.panel-toggle-btn');
            
            if (rightPanel.classList.contains('collapsed')) {
                // パネルを展開
                rightPanel.classList.remove('collapsed');
                outputSection.style.display = 'block';
                expandBtn.style.display = 'none';
                toggleBtn.textContent = '非表示';
            } else {
                // パネルを折りたたみ
                rightPanel.classList.add('collapsed');
                outputSection.style.display = 'none';
                expandBtn.style.display = 'block';
                toggleBtn.textContent = '表示';
            }
        }

        // 実行開始時に自動でパネルを表示
        function showOutputPanel() {
            const rightPanel = document.getElementById('rightPanel');
            const outputSection = rightPanel.querySelector('.output-section');
            const expandBtn = rightPanel.querySelector('.panel-expand-btn');
            const toggleBtn = rightPanel.querySelector('.panel-toggle-btn');
            
            rightPanel.classList.remove('collapsed');
            outputSection.style.display = 'block';
            expandBtn.style.display = 'none';
            toggleBtn.textContent = '非表示';
        }

        // 実行結果パネルの自動スクロール
        function scrollOutputToBottom() {
            const outputConsole = document.getElementById('outputConsole');
            if (outputConsole) {
                outputConsole.scrollTop = outputConsole.scrollHeight;
            }
        }

        // パネルリサイズ機能
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        function initializeResize() {
            const resizeHandle = document.getElementById('resizeHandle');
            const rightPanel = document.getElementById('rightPanel');
            
            resizeHandle.addEventListener('mousedown', startResize);
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
        }

        function startResize(e) {
            isResizing = true;
            startX = e.clientX;
            const rightPanel = document.getElementById('rightPanel');
            startWidth = parseInt(window.getComputedStyle(rightPanel).getPropertyValue('flex-basis'), 10);
            
            // ドラッグ中のスタイル
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        }

        function doResize(e) {
            if (!isResizing) return;
            
            const diff = startX - e.clientX;
            const newWidth = startWidth + diff;
            const rightPanel = document.getElementById('rightPanel');
            
            // 最小幅と最大幅の制限
            const minWidth = 250;
            const maxWidth = 600;
            const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
            
            rightPanel.style.flexBasis = constrainedWidth + 'px';
        }

        function stopResize(e) {
            if (!isResizing) return;
            
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }

        // ページ読み込み時の初期化
        window.onload = function() {
            init();
            // 共有されたコードを自動読み込み
            loadSharedCodeIfAvailable();
        };

        // 共有されたコードの自動読み込み機能
        function loadSharedCodeIfAvailable() {
            const sharedCode = window.getSharedCode && window.getSharedCode();
            
            if (sharedCode) {
                // コードを入力エリアに設定
                const codeInput = document.getElementById('codeInput');
                if (codeInput) {
                    codeInput.value = sharedCode;
                    displayCode(sharedCode);
                    
                    // 通知を表示
                    if (window.showNotification) {
                        window.showNotification('採点システムからコードが共有されました！', 'success');
                    }
                    
                    // コードがある場合、自動的に実行モードを全自動に設定
                    const autoModeRadio = document.querySelector('input[name="executionMode"][value="auto"]');
                    if (autoModeRadio) {
                        autoModeRadio.checked = true;
                        onExecutionModeChange();
                    }
                }
            }
        }
    </script>
    
    <!-- 共通ナビゲーション機能 -->
    <script src="/assets/js/navigation.js"></script>
</body>
</html>
